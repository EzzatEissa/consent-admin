import { Observer, Subject } from 'rxjs';
import { EventsMap } from '../constants/events';
import { TreeEvent } from './events';
import { TreeNode } from './tree-node';
import { TreeDataOptions } from './tree-options';
export interface ScrollIntoViewTarget {
    node: TreeNode;
    force: boolean;
    scrollToMiddle: boolean;
}
export declare class TreeModel {
    private nodes;
    events: EventsMap;
    /**
     * Options that are passed to the tree component
     */
    options: TreeDataOptions;
    /**
     * static cache for recording the tree model while using multiple tree component in same container.
     */
    static focusedTree: TreeModel;
    /**
     * All root nodes, it will have one item if a user input a single root tree.
     */
    roots: TreeNode[];
    /**
     * a tree node created internally to represent the root node of input data
     */
    readonly virtualRoot: TreeNode;
    readonly scrollIntoView$: Subject<ScrollIntoViewTarget>;
    /**
     * Is the tree currently focused
     */
    readonly isFocused: boolean;
    /**
     * if the tree is empty
     */
    readonly isEmptyTree: boolean;
    /**
     * Current focused node
     */
    readonly focusedNode: TreeNode;
    /**
     * @returns Current expanded nodes
     */
    readonly expandedNodes: TreeNode[];
    /**
     * @returns Current active (selected) nodes
     */
    readonly activeNodes: TreeNode[];
    private focusedNodeId;
    private expandedNodeIds;
    private activeNodeIds;
    private hiddenNodeIds;
    private nodeCache;
    constructor(nodes: any[], events: EventsMap, 
        /**
         * Options that are passed to the tree component
         */
        options?: TreeDataOptions);
    addCache(node: TreeNode): void;
    updateOptions(options: TreeDataOptions): void;
    fireEvent(event: TreeEvent): void;
    subscribe(eventName: string, fn: Observer<TreeEvent>): any;
    /**
     * @returns Current active (selected) node. If multiple nodes are active - returns the first one.
     */
    getActiveNode(): TreeNode;
    /**
     * @returns All root nodes that pass the current filter
     */
    getVisibleRoots(): TreeNode[];
    /**
     * @param skipHidden  true or false - whether to skip hidden nodes
     * @returns      first root of the tree
     */
    getFirstRoot(skipHidden?: boolean): TreeNode;
    /**
     * @param skipHidden  true or false - whether to skip hidden nodes
     * @returns      last root of the tree
     */
    getLastRoot(skipHidden?: boolean): TreeNode;
    /**
     * @param     path  array of node IDs to be traversed respectively
     * @param     startNode  optional. Which node to start traversing from
     * @returns   The node, if found - null otherwise
     */
    getNodeByPath(path: (string | number)[], startNode?: TreeNode): TreeNode;
    /**
     * @param     id  node ID to find
     * @returns   The node, if found - null otherwise
     */
    getNodeById(id: string): TreeNode;
    /**
     * @param     predicate - either an object or a function, used as a test condition on all nodes.
     *            Could be every predicate that's supported by lodash's `find` method
     * @param     startNode  optional. Which node to start traversing from
     * @returns   First node that matches the predicate, if found - null otherwise
     */
    getNodeBy(predicate: (node: TreeNode) => boolean, startNode?: TreeNode): any;
    isNodeExpanded(node: TreeNode): boolean;
    isNodeHidden(node: TreeNode): boolean;
    isNodeActive(node: TreeNode): boolean;
    isNodeFocused(node: TreeNode): boolean;
    setActiveNode(node: TreeNode, isActive: boolean, isMulti?: boolean): void;
    setExpandedNodeInPlace(node: TreeNode, isExpanded?: boolean): void;
    setExpandedNode(node: TreeNode, isExpanded?: boolean): void;
    setHiddenNode(node: TreeNode, isHidden?: boolean): void;
    /**
     * Set focus on a node
     * @param node
     */
    setFocusedNode(node: TreeNode): void;
    /**
     * Focuses or blurs the tree
     * @param value  true or false - whether to set focus or blur.
     */
    setFocus(value: boolean): void;
    traverse(fn: (node: TreeNode) => any): void;
    activateNode(id: any): boolean;
    focusNode(id: string): boolean;
    /**
     * Focuses on the next node in the tree (same as down arrow)
     */
    focusNextNode(): void;
    /**
     * Focuses on the previous node in the tree (same as up arrow)
     */
    focusPreviousNode(): void;
    /**
     * Focuses on the inner child of the current focused node (same as right arrow on an expanded node)
     */
    focusDrillDown(): void;
    /**
     * Focuses on the parent of the current focused node (same as left arrow on a collapsed node)
     */
    focusDrillUp(): void;
    /**
     * expand all nodes
     */
    expandAll(): void;
    /**
     * collapse all nodes
     */
    collapseAll(): void;
    performKeyAction(node: TreeNode, $event: KeyboardEvent): boolean;
    /**
     * Marks isHidden field in all nodes recursively according to the filter param.
     * If a node is marked visible, all of its ancestors will be marked visible as well.
     * @param filter  either a string or a function.
     *   In case it's a string, it will be searched case insensitively in the node's display attribute
     *   In case it's a function, it will be passed the node, and should return true if the node should be visible,
     *     false otherwise
     * @param autoShow  if true, make sure all nodes that passed the filter are visible
     */
    filterNodes(filter: string | ((node: TreeNode) => boolean), autoShow?: boolean): void;
    /**
     * Marks all nodes isHidden = false
     */
    clearFilter(): void;
    /**
     * moves a node from one location in the tree to another
     * @param node location has a from and a to attributes, each has a node and index attributes.
     * The combination of node + index tells which node needs to be moved, and to where
     * @param to
     */
    moveNode(node: TreeNode, to: {
        parent: TreeNode;
        index: number;
        dropOnNode: boolean;
    }): void;
    scrollIntoView(node: TreeNode, force: boolean, scrollToMiddle: boolean): void;
    private filterNode(ids, node, filterFn, autoExpand);
    private setSingleActiveNode(node, active);
    private setMultiActiveNodes(node, active);
}
