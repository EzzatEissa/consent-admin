(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('lodash-es/defaults'), require('lodash-es/defaultsDeep'), require('lodash-es/isNumber'), require('lodash-es/first'), require('lodash-es/last'), require('lodash-es/pullAt'), require('lodash-es/without'), require('lodash-es/compact'), require('lodash-es/find'), require('lodash-es/isFunction'), require('lodash-es/isString'), require('rxjs'), require('@angular/core'), require('rxjs/operators'), require('@angular/animations'), require('element-closest'), require('lodash-es/each'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define('@e-cloud/ngx-tree', ['exports', 'lodash-es/defaults', 'lodash-es/defaultsDeep', 'lodash-es/isNumber', 'lodash-es/first', 'lodash-es/last', 'lodash-es/pullAt', 'lodash-es/without', 'lodash-es/compact', 'lodash-es/find', 'lodash-es/isFunction', 'lodash-es/isString', 'rxjs', '@angular/core', 'rxjs/operators', '@angular/animations', 'element-closest', 'lodash-es/each', '@angular/common'], factory) :
	(factory((global['e-cloud'] = global['e-cloud'] || {}, global['e-cloud']['ngx-tree'] = {}),global.defaults,global.defaultsDeep,global.isNumber,global.first,global.last,global.pullAt,global.without,global.compact,global.find,global.isFunction,global.isString,global.rxjs,global.ng.core,global.Rx.Observable.prototype,global.ng.animations,null,global.each,global.ng.common));
}(this, (function (exports,defaults,defaultsDeep,isNumber,first,last,pullAt,without,compact,find,isFunction,isString,rxjs,core,operators,animations,elementClosest,each,common) { 'use strict';

defaults = defaults && defaults.hasOwnProperty('default') ? defaults['default'] : defaults;
defaultsDeep = defaultsDeep && defaultsDeep.hasOwnProperty('default') ? defaultsDeep['default'] : defaultsDeep;
isNumber = isNumber && isNumber.hasOwnProperty('default') ? isNumber['default'] : isNumber;
first = first && first.hasOwnProperty('default') ? first['default'] : first;
last = last && last.hasOwnProperty('default') ? last['default'] : last;
pullAt = pullAt && pullAt.hasOwnProperty('default') ? pullAt['default'] : pullAt;
without = without && without.hasOwnProperty('default') ? without['default'] : without;
compact = compact && compact.hasOwnProperty('default') ? compact['default'] : compact;
find = find && find.hasOwnProperty('default') ? find['default'] : find;
isFunction = isFunction && isFunction.hasOwnProperty('default') ? isFunction['default'] : isFunction;
isString = isString && isString.hasOwnProperty('default') ? isString['default'] : isString;
each = each && each.hasOwnProperty('default') ? each['default'] : each;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */
var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}








function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var NUMBER_KEYS = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    ENTER: 13,
    SPACE: 32,
};
var STRING_KEYS = {
    LEFT: 'ArrowLeft',
    UP: 'ArrowUp',
    RIGHT: 'ArrowRight',
    DOWN: 'ArrowDown',
    ENTER: 'Enter',
    SPACE: ' ',
};
var TREE_ACTIONS = {
    TOGGLE_SELECTED: function (tree, node, $event) { return node && node.toggleActivated(); },
    TOGGLE_SELECTED_MULTI: function (tree, node, $event) { return node && node.toggleActivated(true); },
    SELECT: function (tree, node, $event) { return node.setActive(true); },
    DESELECT: function (tree, node, $event) { return node.setActive(false); },
    FOCUS: function (tree, node, $event) { return node.focus(); },
    TOGGLE_EXPANDED: function (tree, node, $event) {
        $event.stopPropagation();
        return node.hasChildren && node.toggleExpanded();
    },
    EXPAND: function (tree, node, $event) { return node.expand(); },
    COLLAPSE: function (tree, node, $event) { return node.collapse(); },
    DRILL_DOWN: function (tree, node, $event) { return tree.focusDrillDown(); },
    DRILL_UP: function (tree, node, $event) { return tree.focusDrillUp(); },
    NEXT_NODE: function (tree, node, $event) { return tree.focusNextNode(); },
    PREVIOUS_NODE: function (tree, node, $event) { return tree.focusPreviousNode(); },
    MOVE_NODE: function (tree, node, $event, _a) {
        var from = _a.from, to = _a.to;
        tree.moveNode(from, to);
    },
};
var defaultActionMapping = {
    mouse: {
        click: TREE_ACTIONS.TOGGLE_SELECTED,
        dblClick: null,
        contextMenu: null,
        expanderClick: TREE_ACTIONS.TOGGLE_EXPANDED,
        drop: TREE_ACTIONS.MOVE_NODE,
    },
    keys: (_a = {}, _a[NUMBER_KEYS.RIGHT] = TREE_ACTIONS.DRILL_DOWN, _a[NUMBER_KEYS.LEFT] = TREE_ACTIONS.DRILL_UP, _a[NUMBER_KEYS.DOWN] = TREE_ACTIONS.NEXT_NODE, _a[NUMBER_KEYS.UP] = TREE_ACTIONS.PREVIOUS_NODE, _a[NUMBER_KEYS.SPACE] = TREE_ACTIONS.TOGGLE_SELECTED, _a[NUMBER_KEYS.ENTER] = TREE_ACTIONS.TOGGLE_SELECTED, _a),
};
var defaultUIOptions = {
    allowDrag: false,
    allowDrop: false,
    levelPadding: function () { return '0px'; },
    useVirtualScroll: false,
    nodeClass: function () { return ''; },
};
var defaultDataOptions = {
    childrenField: 'children',
    displayField: 'name',
    idField: 'id',
    isExpandedField: 'isExpanded',
    actionMapping: defaultActionMapping,
    getChildren: function (node) { return null; },
};
function createTreeUIOptions(rawOpts) {
    if (rawOpts === void 0) { rawOpts = {}; }
    var levelPaddingOpt = rawOpts.levelPadding;
    if (isNumber(levelPaddingOpt)) {
        rawOpts.levelPadding = function (node) {
            return (levelPaddingOpt + levelPaddingOpt * (node.level - 1)) + 'px';
        };
    }
    return defaults({}, rawOpts, defaultUIOptions);
}
function createTreeDataOptions(rawOpts) {
    if (rawOpts === void 0) { rawOpts = {}; }
    return defaultsDeep({}, rawOpts, defaultDataOptions);
}
var TREE_EVENTS = {
    expand: 'expand',
    collapse: 'collapse',
    toggleExpander: 'toggleExpander',
    activate: 'activate',
    deactivate: 'deactivate',
    focus: 'focus',
    blur: 'blur',
    initialized: 'initialized',
    moveNode: 'moveNode',
    loadChildren: 'loadChildren',
    changeFilter: 'changeFilter',
    removeNode: 'removeNode',
    addNode: 'addNode',
};
var TreeNode = /** @class */ (function () {
    function TreeNode(data, parent, treeModel, index) {
        this.data = data;
        this.parent = parent;
        this.treeModel = treeModel;
        this.index = index;
        this.position = 0;
        this.height = 0;
        this.loadingChildren = false;
        if (this.id === undefined || this.id === null) {
            this.id = uuid();
        }
        treeModel.addCache(this);
        if (data[this.options.isExpandedField]) {
            treeModel.setExpandedNodeInPlace(this);
        }
        if (this.getField('children')) {
            this.initChildren();
        }
    }
    Object.defineProperty(TreeNode.prototype, "isHidden", {
        get: function () {
            return this.treeModel.isNodeHidden(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "isExpanded", {
        get: function () {
            return this.treeModel.isNodeExpanded(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "isCollapsed", {
        get: function () {
            return !this.isExpanded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "isActive", {
        get: function () {
            return this.treeModel.isNodeActive(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "isFocused", {
        get: function () {
            return this.treeModel.isNodeFocused(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "isLeaf", {
        get: function () {
            return !this.hasChildren;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "isRoot", {
        get: function () {
            return this.parent === null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "level", {
        get: function () {
            return this.parent ? this.parent.level + 1 : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "path", {
        get: function () {
            return this.parent ? __spread(this.parent.path, [this.id]) : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "hasChildren", {
        get: function () {
            return !!(this.data.hasChildren || (this.children && this.children.length > 0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "hasVisibleChildren", {
        get: function () {
            return !!(this.data.hasChildren || (this.visibleChildren && this.visibleChildren.length > 0));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "options", {
        get: function () {
            return this.treeModel.options;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "displayField", {
        get: function () {
            return this.getField('display');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "id", {
        get: function () {
            return this.getField('id');
        },
        set: function (value) {
            this.setField('id', value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNode.prototype, "visibleChildren", {
        get: function () {
            return (this.children || []).filter(function (node) { return !node.isHidden; });
        },
        enumerable: true,
        configurable: true
    });
    TreeNode.prototype.fireEvent = function (event) {
        this.treeModel.fireEvent(event);
    };
    TreeNode.prototype.getField = function (key) {
        return this.data[this.options[key + "Field"]];
    };
    TreeNode.prototype.setField = function (key, value) {
        this.data[this.options[key + "Field"]] = value;
    };
    TreeNode.prototype.onDrop = function ($event) {
        this.mouseAction('drop', $event.event, {
            from: $event.element,
            to: { parent: this, index: 0, dropOnNode: true },
        });
    };
    TreeNode.prototype.findAdjacentSibling = function (steps, skipHidden) {
        if (skipHidden === void 0) { skipHidden = false; }
        return this.getParentChildren(skipHidden)[this.index + steps];
    };
    TreeNode.prototype.findNextSibling = function (skipHidden) {
        if (skipHidden === void 0) { skipHidden = false; }
        return this.findAdjacentSibling(+1, skipHidden);
    };
    TreeNode.prototype.findPreviousSibling = function (skipHidden) {
        if (skipHidden === void 0) { skipHidden = false; }
        return this.findAdjacentSibling(-1, skipHidden);
    };
    TreeNode.prototype.getFirstChild = function (skipHidden) {
        if (skipHidden === void 0) { skipHidden = false; }
        var children = skipHidden ? this.visibleChildren : this.children;
        return first(children || []);
    };
    TreeNode.prototype.getLastChild = function (skipHidden) {
        if (skipHidden === void 0) { skipHidden = false; }
        var children = skipHidden ? this.visibleChildren : this.children;
        return last(children || []);
    };
    TreeNode.prototype.findNextNode = function (goInside, skipHidden) {
        if (goInside === void 0) { goInside = true; }
        if (skipHidden === void 0) { skipHidden = false; }
        return goInside && this.isExpanded && this.getFirstChild(skipHidden) ||
            this.findNextSibling(skipHidden) ||
            this.parent && this.parent.findNextNode(false, skipHidden);
    };
    TreeNode.prototype.findPreviousNode = function (skipHidden) {
        if (skipHidden === void 0) { skipHidden = false; }
        var previousSibling = this.findPreviousSibling(skipHidden);
        if (!previousSibling) {
            return this.parent;
        }
        return previousSibling.getLastOpenDescendant(skipHidden);
    };
    TreeNode.prototype.isDescendantOf = function (node) {
        if (this === node) {
            return true;
        }
        else {
            return this.parent && this.parent.isDescendantOf(node);
        }
    };
    TreeNode.prototype.loadChildren = function () {
        var _this = this;
        if (!this.options.getChildren) {
            return Promise.resolve();
        }
        this.loadingChildren = true;
        return Promise.resolve(this.options.getChildren(this))
            .then(function (children) {
            if (children) {
                _this.setField('children', children);
                _this.initChildren();
            }
        })
            .then(function () {
            _this.loadingChildren = false;
            _this.fireEvent({
                eventName: TREE_EVENTS.loadChildren,
                node: _this,
            });
        });
    };
    TreeNode.prototype.expand = function () {
        if (!this.isExpanded) {
            return this.toggleExpanded();
        }
        return Promise.resolve();
    };
    TreeNode.prototype.collapse = function () {
        if (this.isExpanded) {
            this.toggleExpanded();
        }
        return this;
    };
    TreeNode.prototype.traverse = function (fn) {
        var _this = this;
        Promise.resolve(fn(this)).then(function () {
            if (_this.children) {
                _this.children.forEach(function (child) { return child.traverse(fn); });
            }
        });
    };
    TreeNode.prototype.expandAll = function () {
        this.traverse(function (node) { return node.expand(); });
    };
    TreeNode.prototype.collapseAll = function () {
        this.traverse(function (node) { return node.collapse(); });
    };
    TreeNode.prototype.toggleExpanded = function (isExpanded) {
        if (isExpanded === void 0) { isExpanded = !this.isExpanded; }
        if (this.hasChildren) {
            this.treeModel.setExpandedNode(this, isExpanded);
            if (!this.children && this.hasChildren && isExpanded) {
                return this.loadChildren();
            }
        }
        return Promise.resolve();
    };
    TreeNode.prototype.setActive = function (isActive, isMulti) {
        if (isActive === void 0) { isActive = true; }
        if (isMulti === void 0) { isMulti = false; }
        this.treeModel.setActiveNode(this, isActive, isMulti);
        return this;
    };
    TreeNode.prototype.setHidden = function (isHidden) {
        if (isHidden === void 0) { isHidden = true; }
        this.treeModel.setHiddenNode(this, isHidden);
        return this;
    };
    TreeNode.prototype.toggleActivated = function (isMulti) {
        if (isMulti === void 0) { isMulti = false; }
        this.setActive(!this.isActive, isMulti);
        return this;
    };
    TreeNode.prototype.setActiveAndVisible = function (isMulti) {
        if (isMulti === void 0) { isMulti = false; }
        this.setActive(true, isMulti)
            .ensureVisible();
        this.scrollIntoView();
        return this;
    };
    TreeNode.prototype.ensureVisible = function () {
        if (this.parent) {
            this.parent.expand();
            this.parent.ensureVisible();
        }
        return this;
    };
    TreeNode.prototype.scrollIntoView = function (force, scrollToMiddle) {
        if (force === void 0) { force = false; }
        this.treeModel.scrollIntoView(this, force, scrollToMiddle);
    };
    TreeNode.prototype.focus = function (scroll) {
        if (scroll === void 0) { scroll = true; }
        var previousNode = this.treeModel.focusedNode;
        this.treeModel.setFocusedNode(this);
        if (scroll) {
            this.scrollIntoView();
        }
        if (previousNode) {
            this.fireEvent({ eventName: TREE_EVENTS.blur, node: previousNode });
        }
        this.fireEvent({ eventName: TREE_EVENTS.focus, node: this });
        return this;
    };
    TreeNode.prototype.blur = function () {
        var previousNode = this.treeModel.focusedNode;
        this.treeModel.setFocusedNode(null);
        if (previousNode) {
            this.fireEvent({ eventName: TREE_EVENTS.blur, node: this });
        }
        return this;
    };
    TreeNode.prototype.hide = function () {
        this.setHidden(true);
        return this;
    };
    TreeNode.prototype.show = function () {
        this.setHidden(false);
        return this;
    };
    TreeNode.prototype.addChild = function (data, index) {
        var node = new TreeNode(data, this, this.treeModel, index);
        if (!this.getField('children')) {
            this.setField('children', []);
        }
        if (this.children) {
            this.getField('children').splice(index, 0, data);
            this.children.splice(index, 0, node);
            this.children = this.children.slice();
        }
        else {
            this.getField('children').push(data);
            this.children = [node];
        }
        this.reCalcChildrenIndices(index);
        this.fireEvent({ eventName: TREE_EVENTS.addNode, node: node });
    };
    TreeNode.prototype.appendChild = function (data) {
        this.addChild(data, this.children ? this.children.length : 0);
    };
    TreeNode.prototype.remove = function () {
        this.parent.removeChild(this);
    };
    TreeNode.prototype.removeChild = function (node) {
        pullAt(this.getField('children'), node.index);
        this.children = without(this.children, node);
        this.reCalcChildrenIndices(0);
        this.fireEvent({ eventName: TREE_EVENTS.removeNode, node: node });
        if (node.isFocused) {
            this.treeModel.setFocusedNode(null);
            this.treeModel.setActiveNode(node, false);
        }
        if (node.isExpanded) {
            this.treeModel.setExpandedNodeInPlace(node, false);
        }
        node.treeModel = null;
        node.elementRef = null;
    };
    TreeNode.prototype.mouseAction = function (actionName, $event, data) {
        if (data === void 0) { data = null; }
        this.treeModel.setFocus(true);
        var actionMapping = this.options.actionMapping.mouse;
        var action = actionMapping[actionName];
        if (action) {
            action(this.treeModel, this, $event, data);
        }
    };
    TreeNode.prototype.reCalcChildrenIndices = function (offset) {
        this.children.slice(offset).forEach(function (child, index) {
            child.index = index + offset;
        });
    };
    TreeNode.prototype.initChildren = function () {
        var _this = this;
        this.children = this.getField('children')
            .map(function (data, index) { return new TreeNode(data, _this, _this.treeModel, index); });
    };
    TreeNode.prototype.getLastOpenDescendant = function (skipHidden) {
        if (skipHidden === void 0) { skipHidden = false; }
        var lastChild = this.getLastChild(skipHidden);
        return (this.isCollapsed || !lastChild)
            ? this
            : lastChild.getLastOpenDescendant(skipHidden);
    };
    TreeNode.prototype.getParentChildren = function (skipHidden) {
        if (skipHidden === void 0) { skipHidden = false; }
        return this.parent
            ? (skipHidden ? this.parent.visibleChildren : this.parent.children)
            : [];
    };
    return TreeNode;
}());
var _uuid = 0;
function uuid() {
    return "ngx-tid-" + _uuid++;
}
var TreeModel = /** @class */ (function () {
    function TreeModel(nodes, events, options) {
        this.nodes = nodes;
        this.events = events;
        this.options = options;
        this.scrollIntoView$ = new rxjs.Subject();
        this.focusedNodeId = null;
        this.expandedNodeIds = new Map();
        this.activeNodeIds = new Map();
        this.hiddenNodeIds = new Map();
        this.nodeCache = new Map();
        this.options = createTreeDataOptions(options);
        var virtualRootConfig = (_a = {
                virtual: true
            }, _a[this.options.childrenField] = this.nodes, _a);
        this.virtualRoot = new TreeNode(virtualRootConfig, null, this, 0);
        this.setExpandedNodeInPlace(this.virtualRoot);
        this.roots = this.virtualRoot.children;
        var _a;
    }
    Object.defineProperty(TreeModel.prototype, "isFocused", {
        get: function () {
            return TreeModel.focusedTree === this;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeModel.prototype, "isEmptyTree", {
        get: function () {
            return this.roots && this.roots.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeModel.prototype, "focusedNode", {
        get: function () {
            return this.focusedNodeId ? this.getNodeById(this.focusedNodeId) : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeModel.prototype, "expandedNodes", {
        get: function () {
            var _this = this;
            var nodes = Array.from(this.expandedNodeIds.keys())
                .filter(function (id) { return _this.expandedNodeIds.get(id); })
                .map(function (id) { return _this.getNodeById(id); });
            return compact(nodes);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeModel.prototype, "activeNodes", {
        get: function () {
            var _this = this;
            var nodes = Array.from(this.activeNodeIds.keys())
                .filter(function (id) { return _this.activeNodeIds.get(id); })
                .map(function (id) { return _this.nodeCache.get(id); });
            return compact(nodes);
        },
        enumerable: true,
        configurable: true
    });
    TreeModel.prototype.addCache = function (node) {
        this.nodeCache.set(node.id, node);
    };
    TreeModel.prototype.updateOptions = function (options) {
        this.options = options;
    };
    TreeModel.prototype.fireEvent = function (event) {
        this.events[event.eventName].emit(event);
    };
    TreeModel.prototype.subscribe = function (eventName, fn) {
        return this.events[eventName].subscribe(fn);
    };
    TreeModel.prototype.getActiveNode = function () {
        return this.activeNodes[0];
    };
    TreeModel.prototype.getVisibleRoots = function () {
        return this.virtualRoot.visibleChildren;
    };
    TreeModel.prototype.getFirstRoot = function (skipHidden) {
        if (skipHidden === void 0) { skipHidden = false; }
        return first(skipHidden ? this.getVisibleRoots() : this.roots);
    };
    TreeModel.prototype.getLastRoot = function (skipHidden) {
        if (skipHidden === void 0) { skipHidden = false; }
        return last(skipHidden ? this.getVisibleRoots() : this.roots);
    };
    TreeModel.prototype.getNodeByPath = function (path, startNode) {
        if (startNode === void 0) { startNode = null; }
        if (!path) {
            return null;
        }
        startNode = startNode || this.virtualRoot;
        if (path.length === 0) {
            return startNode;
        }
        if (!startNode.children) {
            return null;
        }
        var childId = path.shift();
        var childNode = find(startNode.children, ({ id: childId }));
        if (!childNode) {
            return null;
        }
        return this.getNodeByPath(path, childNode);
    };
    TreeModel.prototype.getNodeById = function (id) {
        return this.nodeCache.get(id);
    };
    TreeModel.prototype.getNodeBy = function (predicate, startNode) {
        if (startNode === void 0) { startNode = null; }
        startNode = startNode || this.virtualRoot;
        if (!startNode.children) {
            return null;
        }
        var found = find(startNode.children, predicate);
        if (found) {
            return found;
        }
        else {
            try {
                for (var _a = __values(startNode.children), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var child = _b.value;
                    var foundInChildren = this.getNodeBy(predicate, child);
                    if (foundInChildren) {
                        return foundInChildren;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        var e_1, _c;
    };
    TreeModel.prototype.isNodeExpanded = function (node) {
        return !!this.expandedNodeIds.get(node.id);
    };
    TreeModel.prototype.isNodeHidden = function (node) {
        return !!this.hiddenNodeIds.get(node.id);
    };
    TreeModel.prototype.isNodeActive = function (node) {
        return !!this.activeNodeIds.get(node.id);
    };
    TreeModel.prototype.isNodeFocused = function (node) {
        return this.focusedNode === node;
    };
    TreeModel.prototype.setActiveNode = function (node, isActive, isMulti) {
        if (isMulti === void 0) { isMulti = false; }
        if (isMulti) {
            this.setMultiActiveNodes(node, isActive);
        }
        else {
            this.setSingleActiveNode(node, isActive);
        }
        if (isActive) {
            node.focus();
            this.fireEvent({ eventName: TREE_EVENTS.activate, node: node });
        }
        else {
            this.fireEvent({ eventName: TREE_EVENTS.deactivate, node: node });
        }
    };
    TreeModel.prototype.setExpandedNodeInPlace = function (node, isExpanded) {
        if (isExpanded === void 0) { isExpanded = true; }
        this.expandedNodeIds.set(node.id, isExpanded);
    };
    TreeModel.prototype.setExpandedNode = function (node, isExpanded) {
        if (isExpanded === void 0) { isExpanded = true; }
        this.expandedNodeIds.set(node.id, isExpanded);
        if (isExpanded) {
            this.fireEvent({ eventName: TREE_EVENTS.expand, node: node });
        }
        else {
            this.fireEvent({ eventName: TREE_EVENTS.collapse, node: node });
        }
        this.fireEvent({ eventName: TREE_EVENTS.toggleExpander, node: node, isExpanded: isExpanded });
    };
    TreeModel.prototype.setHiddenNode = function (node, isHidden) {
        if (isHidden === void 0) { isHidden = true; }
        this.hiddenNodeIds.set(node.id, isHidden);
    };
    TreeModel.prototype.setFocusedNode = function (node) {
        this.focusedNodeId = node ? node.id : null;
    };
    TreeModel.prototype.setFocus = function (value) {
        TreeModel.focusedTree = value ? this : null;
    };
    TreeModel.prototype.traverse = function (fn) {
        this.roots.forEach(function (root) { return root.traverse(fn); });
    };
    TreeModel.prototype.activateNode = function (id) {
        var target = this.getNodeById(id);
        if (target) {
            target.setActiveAndVisible();
            return true;
        }
        return false;
    };
    TreeModel.prototype.focusNode = function (id) {
        var target = this.getNodeById(id);
        if (target) {
            target.focus();
            return true;
        }
        return false;
    };
    TreeModel.prototype.focusNextNode = function () {
        var previousNode = this.focusedNode;
        var nextNode = previousNode ? previousNode.findNextNode(true, true) : this.getFirstRoot(true);
        if (nextNode) {
            nextNode.focus();
        }
    };
    TreeModel.prototype.focusPreviousNode = function () {
        var previousNode = this.focusedNode;
        var nextNode = previousNode ? previousNode.findPreviousNode(true) : this.getLastRoot(true);
        if (nextNode) {
            nextNode.focus();
        }
    };
    TreeModel.prototype.focusDrillDown = function () {
        var previousNode = this.focusedNode;
        if (previousNode && previousNode.isCollapsed && previousNode.hasChildren) {
            previousNode.toggleExpanded();
        }
        else {
            var nextNode = previousNode ? previousNode.getFirstChild(true) : this.getFirstRoot(true);
            if (nextNode) {
                nextNode.focus();
            }
        }
    };
    TreeModel.prototype.focusDrillUp = function () {
        var previousNode = this.focusedNode;
        if (!previousNode) {
            return;
        }
        if (previousNode.isExpanded) {
            previousNode.toggleExpanded();
        }
        else {
            var nextNode = previousNode.parent;
            if (nextNode) {
                nextNode.focus();
            }
        }
    };
    TreeModel.prototype.expandAll = function () {
        this.roots.forEach(function (root) { return root.expandAll(); });
    };
    TreeModel.prototype.collapseAll = function () {
        this.roots.forEach(function (root) { return root.collapseAll(); });
    };
    TreeModel.prototype.performKeyAction = function (node, $event) {
        var action = this.options.actionMapping.keys[$event.keyCode];
        if (action) {
            $event.preventDefault();
            action(this, node, $event);
            return true;
        }
        else {
            return false;
        }
    };
    TreeModel.prototype.filterNodes = function (filter$$1, autoShow) {
        var _this = this;
        if (autoShow === void 0) { autoShow = true; }
        var filterFn;
        if (!filter$$1) {
            return this.clearFilter();
        }
        if (isString(filter$$1)) {
            filterFn = function (node) { return node.displayField.toLowerCase().includes(filter$$1.toLowerCase()); };
        }
        else if (isFunction(filter$$1)) {
            filterFn = filter$$1;
        }
        else {
            throw new TypeError("Don't know what to do with filter: " + filter$$1 + ". It should be either a string or function");
        }
        var ids = new Map();
        this.roots.forEach(function (node) { return _this.filterNode(ids, node, filterFn, autoShow); });
        this.hiddenNodeIds = ids;
        this.fireEvent({ eventName: TREE_EVENTS.changeFilter });
    };
    TreeModel.prototype.clearFilter = function () {
        this.hiddenNodeIds = new Map();
        this.fireEvent({ eventName: TREE_EVENTS.changeFilter });
    };
    TreeModel.prototype.moveNode = function (node, to) {
        var fromIndex = node.index;
        var fromParent = node.parent;
        if (!canMoveNode(node, fromIndex, to)) {
            return;
        }
        node.remove();
        var toIndex = (fromParent === to.parent && to.index > fromIndex) ? to.index - 1 : to.index;
        if (to.dropOnNode) {
            to.parent.appendChild(node.data);
        }
        else {
            to.parent.addChild(node.data, toIndex);
        }
        this.fireEvent({
            eventName: TREE_EVENTS.moveNode,
            node: node,
            to: { parent: to.parent.data, index: toIndex },
        });
    };
    TreeModel.prototype.scrollIntoView = function (node, force, scrollToMiddle) {
        this.scrollIntoView$.next({
            node: node, force: force, scrollToMiddle: scrollToMiddle,
        });
    };
    TreeModel.prototype.filterNode = function (ids, node, filterFn, autoExpand) {
        var _this = this;
        var isVisible = filterFn(node);
        if (node.children) {
            node.children.forEach(function (child) {
                if (_this.filterNode(ids, child, filterFn, autoExpand)) {
                    isVisible = true;
                }
            });
        }
        if (!isVisible) {
            ids.set(node.id, true);
        }
        if (autoExpand && isVisible) {
            node.ensureVisible();
        }
        return isVisible;
    };
    TreeModel.prototype.setSingleActiveNode = function (node, active) {
        var _this = this;
        this.activeNodes
            .filter(function (activeNode) { return activeNode !== node; })
            .forEach(function (activeNode) {
            _this.fireEvent({ eventName: TREE_EVENTS.deactivate, node: activeNode });
        });
        if (active) {
            this.activeNodeIds = new Map([[node.id, true]]);
        }
        else {
            this.activeNodeIds = new Map();
        }
    };
    TreeModel.prototype.setMultiActiveNodes = function (node, active) {
        this.activeNodeIds.set(node.id, active);
    };
    return TreeModel;
}());
TreeModel.focusedTree = null;
function canMoveNode(node, fromIndex, to) {
    if (node.parent === to.parent && fromIndex === to.index) {
        return false;
    }
    return !to.parent.isDescendantOf(node);
}
var TreeLoadingComponent = /** @class */ (function () {
    function TreeLoadingComponent() {
        this.className = true;
    }
    return TreeLoadingComponent;
}());
TreeLoadingComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-tree-loading',
                template: "<span *ngIf=\"!template\">loading...</span>\n\n<ng-container\n  [ngTemplateOutlet]=\"template\"\n  [ngTemplateOutletContext]=\"{ $implicit: null, node: node }\">\n</ng-container>\n",
                styles: [":host{white-space:nowrap}"],
                changeDetection: core.ChangeDetectionStrategy.OnPush,
            },] },
];
TreeLoadingComponent.propDecorators = {
    "template": [{ type: core.Input },],
    "node": [{ type: core.Input },],
    "className": [{ type: core.HostBinding, args: ['class.tree-loading',] },],
};
var Y_OFFSET_NODE_SIZE = 3;
var id = 0;
var VIRTUAL_SCROLL_NODE_HEIGHT_QUOTA = new core.InjectionToken('VIRTUAL_SCROLL_NODE_HEIGHT_QUOTA');
var TreeVirtualScroll = /** @class */ (function () {
    function TreeVirtualScroll(quota) {
        this.quota = quota;
        this.averageNodeHeight = 0;
        this.hasEnoughNodeHeight = false;
        this.lastScrollTop = 0;
        this.disabled = false;
        this.collectionMonitor$ = new rxjs.BehaviorSubject(null);
        this.nodeHeightAnalytics$ = new rxjs.Subject();
        this.id = id++;
        this.collectAverageNodeHeight();
    }
    TreeVirtualScroll.prototype.adjustViewport = function (viewport, scrollTop) {
        this.lastScrollTop = scrollTop;
        this.currentViewport = viewport;
        var Y_OFFSET = this.averageNodeHeight * Y_OFFSET_NODE_SIZE;
        var startPos = scrollTop > Y_OFFSET ? scrollTop - Y_OFFSET : 0;
        var endPos = viewport.height + scrollTop + Y_OFFSET;
        this.collectionMonitor$.next({
            startPos: startPos,
            endPos: endPos,
        });
    };
    TreeVirtualScroll.prototype.waitForCollection = function (observer) {
        return this.collectionMonitor$
            .pipe(operators.filter(function (val) { return !!val; }))
            .subscribe(observer);
    };
    TreeVirtualScroll.prototype.reportNodeHeight = function (data) {
        this.nodeHeightAnalytics$.next(data);
    };
    TreeVirtualScroll.prototype.reCalcPositions = function (treeModel) {
        treeModel.roots.forEach(function (node) {
            node.position = 0;
        });
        treeModel.virtualRoot.height = this.getPositionAfter(treeModel.getVisibleRoots(), 0);
    };
    TreeVirtualScroll.prototype.setDisabled = function (isDisabled) {
        this.disabled = isDisabled;
    };
    TreeVirtualScroll.prototype.isDisabled = function () {
        return this.disabled;
    };
    TreeVirtualScroll.prototype.scrollIntoView = function (node, force, scrollToMiddle) {
        if (scrollToMiddle === void 0) { scrollToMiddle = true; }
        if (force ||
            node.position < this.lastScrollTop ||
            node.position + this.averageNodeHeight > this.lastScrollTop + this.currentViewport.height) {
            return scrollToMiddle ? node.position - this.currentViewport.height / 2 + this.averageNodeHeight :
                node.position;
        }
        return null;
    };
    TreeVirtualScroll.prototype.getPositionAfter = function (nodes, startPos) {
        var _this = this;
        var position = startPos;
        nodes.forEach(function (node) {
            node.position = position;
            position = _this.getPositionAfterNode(node, node.position, node.isHidden);
        });
        return position;
    };
    TreeVirtualScroll.prototype.getPositionAfterNode = function (node, startPos, isPrevShadow) {
        if (isPrevShadow === void 0) { isPrevShadow = false; }
        var position = isPrevShadow ? startPos : this.averageNodeHeight + startPos;
        if (node.children && node.isExpanded) {
            position = this.getPositionAfter(node.visibleChildren, position);
        }
        node.height = position - startPos + (node.loadingChildren ? this.averageNodeHeight : 0);
        return position;
    };
    TreeVirtualScroll.prototype.collectAverageNodeHeight = function () {
        var _this = this;
        this.nodeHeightAnalytics$
            .pipe(operators.scan(function (acc, cur) {
            var lastAvg = acc[0] / acc[1];
            var sum = cur + acc[0];
            var count = acc[1] + 1;
            var avg = sum / count;
            if (avg / lastAvg > 1.5 || lastAvg / avg > 1.5) {
                return [cur, 1];
            }
            return [sum, count];
        }, [0, 0]))
            .subscribe(function (pair) {
            _this.averageNodeHeight = pair[0] / pair[1];
            if (pair[1] >= _this.quota) {
                _this.hasEnoughNodeHeight = true;
            }
        });
    };
    return TreeVirtualScroll;
}());
TreeVirtualScroll.decorators = [
    { type: core.Injectable },
];
TreeVirtualScroll.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Inject, args: [VIRTUAL_SCROLL_NODE_HEIGHT_QUOTA,] },] },
]; };
function binarySearch(nodes, condition, firstIndex) {
    if (firstIndex === void 0) { firstIndex = 0; }
    var left = firstIndex;
    var right = nodes.length - 1;
    while (left !== right) {
        var mid = Math.floor((left + right) / 2);
        if (condition(nodes[mid])) {
            right = mid;
        }
        else {
            if (left === mid) {
                left = right;
            }
            else {
                left = mid;
            }
        }
    }
    return left;
}
var EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';
var TreeNodeChildrenComponent = /** @class */ (function () {
    function TreeNodeChildrenComponent(virtualScroll) {
        this.virtualScroll = virtualScroll;
        this.marginTop = 0;
        this.viewportNodes = [];
        this.disableMarginTop = false;
        this.refreshTree = false;
        this.expandAnimation = true;
        this.className = true;
        this.scrollSub = rxjs.Subscription.EMPTY;
    }
    Object.defineProperty(TreeNodeChildrenComponent.prototype, "noPadding", {
        get: function () {
            return !this.options.levelPadding;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeNodeChildrenComponent.prototype, "marginTopAttr", {
        get: function () {
            return this.disableMarginTop ? 0 : this.marginTop;
        },
        enumerable: true,
        configurable: true
    });
    TreeNodeChildrenComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.viewportNodes = this.children;
        this.scrollSub = this.virtualScroll.waitForCollection(function (metrics) {
            if (_this.node.treeModel && _this.node.isExpanded) {
                _this.viewportNodes = _this.getViewportNodes(_this.node.visibleChildren, metrics);
                _this.marginTop = _this.calcMarginTop();
            }
        });
    };
    TreeNodeChildrenComponent.prototype.ngOnChanges = function (changes) {
        if ('children' in changes && changes["children"].currentValue) {
            this.viewportNodes = this.virtualScroll.isDisabled() || this.refreshTree
                ? this.children : this.viewportNodes;
        }
    };
    TreeNodeChildrenComponent.prototype.ngOnDestroy = function () {
        this.scrollSub.unsubscribe();
    };
    TreeNodeChildrenComponent.prototype.trackNode = function (index, node) {
        return node.id;
    };
    TreeNodeChildrenComponent.prototype.calcMarginTop = function () {
        var firstNode = this.viewportNodes && this.viewportNodes.length && this.viewportNodes[0];
        return firstNode
            ? Math.max(0, firstNode.position - firstNode.parent.position -
                (firstNode.parent.isRoot ? 0 : this.virtualScroll.averageNodeHeight))
            : 0;
    };
    TreeNodeChildrenComponent.prototype.getViewportNodes = function (nodes, _a) {
        var startPos = _a.startPos, endPos = _a.endPos;
        if (!nodes || !nodes.length) {
            return [];
        }
        var firstIndex = binarySearch(nodes, function (node) {
            return startPos <= node.position || (startPos <= node.position + node.height);
        });
        var lastIndex = binarySearch(nodes, function (node) {
            return endPos < node.position || (endPos <= node.position + node.height);
        }, firstIndex);
        var viewportNodes = nodes.slice(firstIndex, lastIndex + 1);
        return viewportNodes;
    };
    return TreeNodeChildrenComponent;
}());
TreeNodeChildrenComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-tree-node-children',
                template: "<ngx-tree-node *ngFor=\"let child of viewportNodes; let i = index; trackBy: trackNode\"\n               [options]=\"options\"\n               [ngClass]=\"[options.nodeClass(child), 'tree-node-level-'+ child.level]\"\n               [class.tree-node-expanded]=\"child.isExpanded\"\n               [class.tree-node-collapsed]=\"child.isCollapsed\"\n               [class.tree-node-leaf]=\"child.isLeaf\"\n               [class.tree-node-active]=\"child.isActive\"\n               [class.tree-node-focused]=\"child.isFocused\"\n               [node]=\"child\"\n               [index]=\"i\"\n               [templates]=\"templates\">\n</ngx-tree-node>\n\n<ngx-tree-loading *ngIf=\"!node.children\"\n                  [style.padding-left]=\"options.levelPadding(node)\"\n                  [template]=\"templates.loadingTemplate\"\n                  [node]=\"node\"></ngx-tree-loading>\n",
                styles: [":host{display:block;padding-left:20px}:host .tree-children-no-padding{padding-left:0}"],
                animations: [
                    animations.trigger('expandAnimation', [
                        animations.transition(':enter', [
                            animations.style({ height: 0, overflow: 'hidden' }),
                            animations.animate(EXPANSION_PANEL_ANIMATION_TIMING, animations.style({ height: '*' })),
                        ]),
                        animations.transition(':leave', [
                            animations.style({ height: '*', overflow: 'hidden' }),
                            animations.animate(EXPANSION_PANEL_ANIMATION_TIMING, animations.style({ height: 0 })),
                        ]),
                    ]),
                ],
            },] },
];
TreeNodeChildrenComponent.ctorParameters = function () { return [
    { type: TreeVirtualScroll, },
]; };
TreeNodeChildrenComponent.propDecorators = {
    "options": [{ type: core.Input },],
    "node": [{ type: core.Input },],
    "templates": [{ type: core.Input },],
    "disableMarginTop": [{ type: core.Input },],
    "children": [{ type: core.Input },],
    "refreshTree": [{ type: core.Input },],
    "expandAnimation": [{ type: core.HostBinding, args: ['@expandAnimation',] },],
    "className": [{ type: core.HostBinding, args: ['class.tree-node-children',] },],
    "noPadding": [{ type: core.HostBinding, args: ['class.tree-children-no-padding',] },],
    "marginTopAttr": [{ type: core.HostBinding, args: ['style.margin-top.px',] },],
};
var TreeNodeContentComponent = /** @class */ (function () {
    function TreeNodeContentComponent() {
        this.className = true;
    }
    return TreeNodeContentComponent;
}());
TreeNodeContentComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-tree-node-content',
                template: "<span *ngIf=\"!template\">{{ node.displayField }}</span>\n\n<ng-container\n  [ngTemplateOutlet]=\"template\"\n  [ngTemplateOutletContext]=\"{ $implicit: null, node: node, index: index, options: options }\">\n</ng-container>\n",
                styles: [":host{display:block;padding:2px 5px;border-radius:2px;-webkit-transition:background-color .15s,-webkit-box-shadow .15s;transition:background-color .15s,-webkit-box-shadow .15s;transition:background-color .15s,box-shadow .15s;transition:background-color .15s,box-shadow .15s,-webkit-box-shadow .15s;cursor:pointer;white-space:nowrap}"],
                changeDetection: core.ChangeDetectionStrategy.OnPush,
            },] },
];
TreeNodeContentComponent.propDecorators = {
    "options": [{ type: core.Input },],
    "node": [{ type: core.Input },],
    "index": [{ type: core.Input },],
    "template": [{ type: core.Input },],
    "className": [{ type: core.HostBinding, args: ['class.tree-node-content',] },],
};
var TreeNodeDropSlotComponent = /** @class */ (function () {
    function TreeNodeDropSlotComponent() {
        var _this = this;
        this.allowDrop = function (element, $event) { return isFunction(_this.options.allowDrop)
            ? _this.options.allowDrop(element, {
                parent: _this.node,
                index: _this.dropIndex,
            }, $event)
            : false; };
    }
    TreeNodeDropSlotComponent.prototype.onDrop = function ($event) {
        this.node.mouseAction('drop', $event.event, {
            from: $event.element,
            to: { parent: this.node, index: this.dropIndex },
        });
    };
    return TreeNodeDropSlotComponent;
}());
TreeNodeDropSlotComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-tree-node-drop-slot',
                template: "<div class=\"tree-node-drop-slot\"\n     (ngxTreeDrop)=\"onDrop($event)\"\n     [treeAllowDrop]=\"allowDrop\">\n</div>\n",
                styles: [":host{display:block;width:100%;z-index:1}:host.prev-drop-slot{top:0}:host.next-drop-slot{bottom:0}.tree-node-drop-slot{display:block;height:4px;background-color:#f08080}.tree-node-drop-slot.is-dragging-over{background:#dfe;outline:#888 dashed 2px}"],
                changeDetection: core.ChangeDetectionStrategy.OnPush,
            },] },
];
TreeNodeDropSlotComponent.propDecorators = {
    "node": [{ type: core.Input },],
    "options": [{ type: core.Input },],
    "dropIndex": [{ type: core.Input },],
};
var TreeNodeExpanderComponent = /** @class */ (function () {
    function TreeNodeExpanderComponent() {
        this.className = true;
    }
    return TreeNodeExpanderComponent;
}());
TreeNodeExpanderComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-tree-node-expander',
                template: "<ng-template [ngIf]=\"!template\">\n  <div *ngIf=\"node.hasChildren\"\n        class=\"toggle-children-wrapper\"\n        [class.toggle-children-expanded]=\"node.isExpanded\"\n        [class.toggle-children-collapsed]=\"node.isCollapsed\"\n        (click)=\"node.mouseAction('expanderClick', $event)\">\n    <span class=\"toggle-children\"></span>\n  </div>\n\n  <div *ngIf=\"!node.hasChildren\"\n        class=\"toggle-children-placeholder\"></div>\n</ng-template>\n\n<ng-container [ngTemplateOutlet]=\"template\"\n              [ngTemplateOutletContext]=\"{\n                $implicit: null,\n                node: node,\n                index: index,\n                options: options\n              }\">\n</ng-container>\n",
                styles: [":host{display:block;white-space:nowrap}.toggle-children-expanded .toggle-children{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.toggle-children-collapsed .toggle-children{-webkit-transform:rotate(0);transform:rotate(0)}.toggle-children-wrapper{padding:0 3px;cursor:pointer}.toggle-children{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAASCAYAAABSO15qAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABAhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjY1RTYzOTA2ODZDRjExREJBNkUyRDg4N0NFQUNCNDA3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkYzRkRFQjcxODUzNTExRTU4RTQwRkQwODFEOUZEMEE3IiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkYzRkRFQjcwODUzNTExRTU4RTQwRkQwODFEOUZEMEE3IiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTk5NzA1OGEtZDI3OC00NDZkLWE4ODgtNGM4MGQ4YWI1NzNmIiBzdFJlZjpkb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6YzRkZmQxMGMtY2NlNS0xMTc4LWE5OGQtY2NkZmM5ODk5YWYwIi8+IDxkYzp0aXRsZT4gPHJkZjpBbHQ+IDxyZGY6bGkgeG1sOmxhbmc9IngtZGVmYXVsdCI+Z2x5cGhpY29uczwvcmRmOmxpPiA8L3JkZjpBbHQ+IDwvZGM6dGl0bGU+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+5iogFwAAAGhJREFUeNpiYGBgKABigf///zOQg0EARH4A4gZyDIIZ8B/JoAJKDIDhB0CcQIkBRBtEyABkgxwoMQCGD6AbRKoBGAYxQgXIBRuZGKgAKPIC3QLxArnRSHZCIjspk52ZKMrOFBUoAAEGAKnq593MQAZtAAAAAElFTkSuQmCC);height:8px;width:9px;background-size:contain;display:inline-block;background-repeat:no-repeat;background-position:center}.toggle-children-placeholder{display:block;height:15px;width:15px}"],
            },] },
];
TreeNodeExpanderComponent.propDecorators = {
    "options": [{ type: core.Input },],
    "node": [{ type: core.Input },],
    "index": [{ type: core.Input },],
    "template": [{ type: core.Input },],
    "className": [{ type: core.HostBinding, args: ['class.tree-node-expander',] },],
};
var TreeNodeWrapperComponent = /** @class */ (function () {
    function TreeNodeWrapperComponent(virtualScroll, elementRef) {
        this.virtualScroll = virtualScroll;
        this.elementRef = elementRef;
        this.className = true;
    }
    TreeNodeWrapperComponent.prototype.ngOnInit = function () {
        this.node.elementRef = this.elementRef;
    };
    TreeNodeWrapperComponent.prototype.ngOnDestroy = function () {
        this.node.elementRef = null;
    };
    TreeNodeWrapperComponent.prototype.ngAfterViewInit = function () {
        if (!this.virtualScroll.isDisabled() && !this.virtualScroll.hasEnoughNodeHeight) {
            this.virtualScroll.reportNodeHeight(this.elementRef.nativeElement.getBoundingClientRect().height);
        }
    };
    return TreeNodeWrapperComponent;
}());
TreeNodeWrapperComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-tree-node-wrapper',
                template: "<ng-template [ngIf]=\"!templates.treeNodeWrapperTemplate\">\n  <ngx-tree-node-expander [node]=\"node\"\n                          [index]=\"index\"\n                          [options]=\"options\"\n                          [template]=\"templates.expanderTemplate\"></ngx-tree-node-expander>\n\n  <ngx-tree-node-content [node]=\"node\"\n                         [index]=\"index\"\n                         [options]=\"options\"\n                         [template]=\"templates.treeNodeTemplate\">\n  </ngx-tree-node-content>\n</ng-template>\n\n<ng-container [ngTemplateOutlet]=\"templates.treeNodeWrapperTemplate\"\n              [ngTemplateOutletContext]=\"{\n                $implicit: null,\n                node: node,\n                index: index,\n                options: options,\n                templates: templates\n              }\">\n</ng-container>\n",
                styles: [":host{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}:host ::ng-deep .tree-node-content:hover{background-color:#f7fbff}:host(.ngx-tree-dragging-target) ::ng-deep .tree-node-expander{visibility:hidden}:host(.tree-node-wrapper-active) ::ng-deep .tree-node-content,:host(.tree-node-wrapper-active) ::ng-deep .tree-node-content:hover,:host(.tree-node-wrapper-active).tree-node-wrapper-focused ::ng-deep .tree-node-content{background-color:#beebff}:host(.tree-node-wrapper-focused) ::ng-deep .tree-node-content{background-color:#e7f4f9}:host ::ng-deep .tree-node-content:hover,:host(.tree-node-wrapper-active) ::ng-deep .tree-node-content,:host(.tree-node-wrapper-focused) ::ng-deep .tree-node-content{-webkit-box-shadow:inset 0 0 1px #999;box-shadow:inset 0 0 1px #999}:host(.is-dragging-over) .tree-node-content{position:relative;z-index:1;background-color:#dfe;-webkit-box-shadow:inset 0 0 1px #999;box-shadow:inset 0 0 1px #999;outline:#888 dashed 2px}:host(.is-dragging-over) .tree-node-content *,:host(.is-dragging-over) .tree-node-expander *{pointer-events:none}:host(.is-dragging-over-disabled) .tree-node-content{opacity:.5}"],
            },] },
];
TreeNodeWrapperComponent.ctorParameters = function () { return [
    { type: TreeVirtualScroll, },
    { type: core.ElementRef, },
]; };
TreeNodeWrapperComponent.propDecorators = {
    "node": [{ type: core.Input },],
    "options": [{ type: core.Input },],
    "index": [{ type: core.Input },],
    "templates": [{ type: core.Input },],
    "className": [{ type: core.HostBinding, args: ['class.tree-node-wrapper',] },],
};
var TreeNodeComponent = /** @class */ (function () {
    function TreeNodeComponent() {
        this.className = true;
    }
    Object.defineProperty(TreeNodeComponent.prototype, "allowDrop", {
        get: function () {
            var _this = this;
            return function (node, $event) {
                return isFunction(_this.options.allowDrop)
                    ? _this.options.allowDrop(node, { parent: _this.node, index: node.index }, $event)
                    : _this.options.allowDrop;
            };
        },
        enumerable: true,
        configurable: true
    });
    TreeNodeComponent.prototype.allowDrag = function (node) {
        return isFunction(this.options.allowDrag) ? this.options.allowDrag(node) : this.options.allowDrag;
    };
    return TreeNodeComponent;
}());
TreeNodeComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-tree-node',
                template: "<ng-template [ngIf]=\"!templates.treeNodeFullTemplate\">\n  <ngx-tree-node-wrapper [style.padding-left]=\"options.levelPadding(node)\"\n                         [node]=\"node\"\n                         [options]=\"options\"\n                         [index]=\"index\"\n                         [templates]=\"templates\"\n                         [class.tree-node-wrapper-active]=\"node.isActive\"\n                         [class.tree-node-wrapper-focused]=\"node.isFocused\"\n                         (click)=\"node.mouseAction('click', $event)\"\n                         (dblclick)=\"node.mouseAction('dblClick', $event)\"\n                         (contextmenu)=\"node.mouseAction('contextMenu', $event)\"\n                         (ngxTreeDrop)=\"node.onDrop($event)\"\n                         (treeDropDragOver)=\"node.mouseAction('dragOver', $event)\"\n                         (treeDropDragLeave)=\"node.mouseAction('dragLeave', $event)\"\n                         (treeDropDragEnter)=\"node.mouseAction('dragEnter', $event)\"\n                         [treeAllowDrop]=\"allowDrop\"\n                         [ngxTreeDrag]=\"node\"\n                         [treeDragEnabled]=\"allowDrag(node)\">\n  </ngx-tree-node-wrapper>\n\n  <ngx-tree-node-children *ngIf=\"node.isExpanded && node.hasVisibleChildren\"\n                          [node]=\"node\"\n                          [options]=\"options\"\n                          [children]=\"node.visibleChildren\"\n                          [templates]=\"templates\"></ngx-tree-node-children>\n</ng-template>\n\n<ng-container\n  [ngTemplateOutlet]=\"templates.treeNodeFullTemplate\"\n  [ngTemplateOutletContext]=\"{ $implicit: null, node: node, index: index, options: options, templates: templates }\">\n</ng-container>\n",
                styles: [":host{display:block;position:relative}"],
            },] },
];
TreeNodeComponent.propDecorators = {
    "node": [{ type: core.Input },],
    "options": [{ type: core.Input },],
    "index": [{ type: core.Input },],
    "templates": [{ type: core.Input },],
    "className": [{ type: core.HostBinding, args: ['class.tree-node',] },],
};
var DISABLE_ON_SCROLL_CLASS = 'disable-events-on-scroll';
var TreeViewportComponent = /** @class */ (function () {
    function TreeViewportComponent(virtualScroll, elementRef, renderer) {
        this.virtualScroll = virtualScroll;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.lastScrollTop = 0;
        this.isScrolling = false;
        this.className = true;
        this.ticking = false;
        this.scrollIntoViewTicking = false;
        this.structureChangeSub = rxjs.Subscription.EMPTY;
        this.scrollIntoViewSub = rxjs.Subscription.EMPTY;
    }
    TreeViewportComponent.prototype.onScroll = function (event) {
        var _this = this;
        this.disableEventsWhenScrolling();
        if (this.virtualScroll.isDisabled()) {
            return;
        }
        var currentScrollTop = this.elementRef.nativeElement.scrollTop;
        if (Math.abs(currentScrollTop - this.lastScrollTop) < this.virtualScroll.averageNodeHeight) {
            return false;
        }
        this.lastScrollTop = currentScrollTop;
        if (!this.ticking) {
            window.requestAnimationFrame(function () {
                _this.setViewport();
                _this.ticking = false;
            });
            this.ticking = true;
        }
        event.preventDefault();
        event.stopPropagation();
        return false;
    };
    TreeViewportComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.scrollIntoViewSub = this.treeModel.scrollIntoView$.subscribe(function (target) {
            if (target.node.elementRef) {
                _this.scrollIntoViewAndTick(target, function () {
                    var lastTarget = _this.lastScrollIntoViewTarget;
                    if (lastTarget.node.elementRef.nativeElement.scrollIntoViewIfNeeded) {
                        lastTarget.node.elementRef.nativeElement.scrollIntoViewIfNeeded(lastTarget.scrollToMiddle);
                    }
                    else {
                        lastTarget.node.elementRef.nativeElement.scrollIntoView({
                            behavior: 'auto',
                            block: 'end',
                        });
                    }
                });
            }
        });
    };
    TreeViewportComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if ('treeModel' in changes) {
            this.virtualScroll.setDisabled(!this.enable);
            if (this.virtualScroll.isDisabled()) {
                if (!changes["treeModel"].isFirstChange()) {
                    this.treeModel.fireEvent({ eventName: TREE_EVENTS.initialized });
                }
                return;
            }
            this.initEventSubscription();
            this.virtualScroll.reCalcPositions(this.treeModel);
            if (!changes["treeModel"].isFirstChange()) {
                setTimeout(function () {
                    _this.setViewport();
                    _this.treeModel.fireEvent({ eventName: TREE_EVENTS.initialized });
                });
            }
        }
    };
    TreeViewportComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () {
            if (_this.virtualScroll.isDisabled()) {
                _this.treeModel.fireEvent({ eventName: TREE_EVENTS.initialized });
                return;
            }
            _this.virtualScroll.reCalcPositions(_this.treeModel);
            _this.setViewport();
            _this.treeModel.fireEvent({ eventName: TREE_EVENTS.initialized });
        });
    };
    TreeViewportComponent.prototype.ngOnDestroy = function () {
        if (this.structureChangeSub) {
            this.structureChangeSub.unsubscribe();
        }
        if (this.scrollIntoViewSub) {
            this.scrollIntoViewSub.unsubscribe();
        }
    };
    TreeViewportComponent.prototype.scrollIntoViewAndTick = function (target, scrollCallback) {
        var _this = this;
        this.lastScrollIntoViewTarget = target;
        if (!this.scrollIntoViewTicking) {
            window.requestAnimationFrame(function () {
                scrollCallback();
                _this.scrollIntoViewTicking = false;
            });
            this.scrollIntoViewTicking = true;
        }
    };
    TreeViewportComponent.prototype.initEventSubscription = function () {
        var _this = this;
        this.ngOnDestroy();
        this.scrollIntoViewSub = this.treeModel.scrollIntoView$.subscribe(function (target) {
            _this.scrollIntoViewAndTick(target, function () {
                var lastTarget = _this.lastScrollIntoViewTarget;
                var targetOffset = _this.virtualScroll.scrollIntoView(lastTarget.node, lastTarget.force, lastTarget.scrollToMiddle);
                if (targetOffset) {
                    _this.elementRef.nativeElement.scrollTop = targetOffset;
                }
            });
        });
        this.structureChangeSub = rxjs.merge(this.treeModel.events.expand, this.treeModel.events.collapse, this.treeModel.events.loadChildren, this.treeModel.events.changeFilter, this.treeModel.events.addNode, this.treeModel.events.removeNode)
            .subscribe(function () {
            _this.virtualScroll.reCalcPositions(_this.treeModel);
            _this.setViewport();
        });
    };
    TreeViewportComponent.prototype.setViewport = function () {
        if (this.virtualScroll.isDisabled()) {
            return;
        }
        this.virtualScroll.adjustViewport(this.elementRef.nativeElement.getBoundingClientRect(), this.lastScrollTop);
    };
    TreeViewportComponent.prototype.disableEventsWhenScrolling = function () {
        var _this = this;
        if (this.scrollTimer) {
            clearTimeout(this.scrollTimer);
        }
        else {
            this.isScrolling = true;
            this.renderer.addClass(this.elementRef.nativeElement, DISABLE_ON_SCROLL_CLASS);
        }
        this.scrollTimer = (setTimeout(function () {
            _this.isScrolling = false;
            _this.renderer.removeClass(_this.elementRef.nativeElement, DISABLE_ON_SCROLL_CLASS);
            _this.scrollTimer = null;
        }, 120));
    };
    return TreeViewportComponent;
}());
TreeViewportComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-tree-viewport',
                template: "<ng-content></ng-content>\n",
                styles: [":host{height:100%;overflow:auto;display:block}"],
                providers: [TreeVirtualScroll],
                changeDetection: core.ChangeDetectionStrategy.OnPush,
            },] },
];
TreeViewportComponent.ctorParameters = function () { return [
    { type: TreeVirtualScroll, },
    { type: core.ElementRef, },
    { type: core.Renderer2, },
]; };
TreeViewportComponent.propDecorators = {
    "enable": [{ type: core.Input },],
    "treeModel": [{ type: core.Input },],
    "className": [{ type: core.HostBinding, args: ['class.tree-viewport',] },],
    "onScroll": [{ type: core.HostListener, args: ['scroll', ['$event'],] },],
};
var TreeDraggingTargetService = /** @class */ (function (_super) {
    __extends(TreeDraggingTargetService, _super);
    function TreeDraggingTargetService() {
        var _this = _super.apply(this, __spread(arguments)) || this;
        _this._draggedElement = null;
        return _this;
    }
    TreeDraggingTargetService.prototype.set = function (draggedElement) {
        this._draggedElement = draggedElement;
    };
    TreeDraggingTargetService.prototype.get = function () {
        return this._draggedElement;
    };
    TreeDraggingTargetService.prototype.isDragging = function () {
        return !!this.get();
    };
    return TreeDraggingTargetService;
}(rxjs.Subject));
TreeDraggingTargetService.decorators = [
    { type: core.Injectable },
];
var TreeComponent = /** @class */ (function () {
    function TreeComponent(treeDraggingTargetService) {
        var _this = this;
        this.treeDraggingTargetService = treeDraggingTargetService;
        this.treeModel = null;
        this.refreshTree = false;
        this.enableAnimation = true;
        this.keepNodesExpanded = false;
        this.expand = null;
        this.collapse = null;
        this.toggleExpander = null;
        this.activate = null;
        this.deactivate = null;
        this.focus = null;
        this.blur = null;
        this.initialized = null;
        this.moveNode = null;
        this.loadChildren = null;
        this.changeFilter = null;
        this.addNode = null;
        this.removeNode = null;
        this.className = true;
        this.emitterMap = (Object.keys(TREE_EVENTS).reduce(function (map, name) {
            if (!_this.hasOwnProperty(name)) {
                throw new TypeError("Unmatched events: [" + name + "]");
            }
            _this[name] = map[name] = new core.EventEmitter();
            return map;
        }, {}));
        this.UIOptions = createTreeUIOptions();
    }
    TreeComponent.prototype.ngOnChanges = function (changes) {
        var _this = this;
        if (changes["nodes"] && changes["nodes"].currentValue) {
            var oldTreeModel = this.treeModel;
            this.treeModel = new TreeModel(changes["nodes"].currentValue, this.emitterMap, this.dataOptions);
            if (oldTreeModel && this.keepNodesExpanded) {
                oldTreeModel.expandedNodes.forEach(function (node) {
                    _this.treeModel.setExpandedNodeInPlace(node);
                });
            }
            if (!changes["nodes"].isFirstChange()) {
                this.refreshTree = true;
            }
        }
        else if (changes["dataOptions"] && changes["dataOptions"].currentValue && this.treeModel) {
            this.treeModel.updateOptions(changes["dataOptions"].currentValue);
        }
        if (changes["focusTarget"] && changes["focusTarget"].currentValue && this.treeModel) {
            this.treeModel.focusNode(this.focusTarget);
        }
        if (changes["activateTarget"] && changes["activateTarget"].currentValue && this.treeModel) {
            this.treeModel.activateNode(this.activateTarget);
        }
        if (changes["allowDrag"] || changes["allowDrop"]
            || changes["levelPadding"]
            || changes["useVirtualScroll"]
            || changes["nodeClass"]) {
            this.UIOptions = createTreeUIOptions({
                allowDrag: this.allowDrag,
                allowDrop: this.allowDrop,
                levelPadding: this.levelPadding,
                useVirtualScroll: this.useVirtualScroll,
                nodeClass: this.nodeClass,
            });
        }
    };
    TreeComponent.prototype.ngOnDestroy = function () {
        each(this.emitterMap, function (emitter) {
            emitter.complete();
        });
    };
    TreeComponent.prototype.onKeydown = function ($event) {
        if (!this.treeModel.isFocused) {
            return;
        }
        if (['input', 'textarea'].includes(document.activeElement.tagName.toLowerCase())) {
            return;
        }
        var focusedNode = this.treeModel.focusedNode;
        this.treeModel.performKeyAction(focusedNode, $event);
    };
    TreeComponent.prototype.onMousedown = function ($event) {
        var insideClick = $event.target.closest('ngx-tree');
        if (!insideClick) {
            this.treeModel.setFocus(false);
        }
    };
    TreeComponent.prototype.sizeChanged = function () {
        this.viewportComponent.setViewport();
    };
    return TreeComponent;
}());
TreeComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ngx-tree',
                template: "<ngx-tree-viewport [@.disabled]=\"!enableAnimation || viewport.isScrolling\"\n                   [enable]=\"useVirtualScroll\"\n                   [treeModel]=\"treeModel\"\n                   #viewport>\n  <div *ngIf=\"!viewport.virtualScroll.isDisabled()\"\n       class=\"height-raiser\"\n       [style.height.px]=\"treeModel?.virtualRoot.height\"></div>\n  <div class=\"tree-root\"\n       [class.node-dragging]=\"treeDraggingTargetService.isDragging()\"\n       [class.virtual-scroll-disabled]=\"viewport.virtualScroll.isDisabled()\"\n       [style.transform]=\"'translateY(' + root.marginTop + 'px)'\">\n    <ngx-tree-node-children #root\n                            [options]=\"UIOptions\"\n                            [disableMarginTop]=\"true\"\n                            [node]=\"treeModel?.virtualRoot\"\n                            [children]=\"treeModel?.roots\"\n                            [refreshTree]=\"refreshTree\"\n                            [templates]=\"{\n                              expanderTemplate: expanderTemplate,\n                              loadingTemplate: loadingTemplate,\n                              treeNodeTemplate: treeNodeTemplate,\n                              treeNodeWrapperTemplate: treeNodeWrapperTemplate,\n                              treeNodeFullTemplate: treeNodeFullTemplate\n                            }\">\n    </ngx-tree-node-children>\n  </div>\n</ngx-tree-viewport>\n",
                styles: [":host{display:block}ngx-tree-viewport{position:relative}ngx-tree-viewport.disable-events-on-scroll .tree-root /deep/ *{pointer-events:none}.tree-children{padding-left:20px}.height-raiser{-webkit-transition:height 250ms ease-in;transition:height 250ms ease-in}.tree-root{top:0;width:100%;height:100%;position:absolute;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.tree-root.virtual-scroll-disabled{position:static}/deep/ .ngx-tree-dragging-target *{pointer-events:none}"],
            },] },
];
TreeComponent.ctorParameters = function () { return [
    { type: TreeDraggingTargetService, },
]; };
TreeComponent.propDecorators = {
    "nodes": [{ type: core.Input },],
    "focusTarget": [{ type: core.Input },],
    "activateTarget": [{ type: core.Input },],
    "dataOptions": [{ type: core.Input },],
    "allowDrag": [{ type: core.Input },],
    "allowDrop": [{ type: core.Input },],
    "levelPadding": [{ type: core.Input },],
    "useVirtualScroll": [{ type: core.Input },],
    "nodeClass": [{ type: core.Input },],
    "enableAnimation": [{ type: core.Input },],
    "keepNodesExpanded": [{ type: core.Input },],
    "expand": [{ type: core.Output },],
    "collapse": [{ type: core.Output },],
    "toggleExpander": [{ type: core.Output },],
    "activate": [{ type: core.Output },],
    "deactivate": [{ type: core.Output },],
    "focus": [{ type: core.Output },],
    "blur": [{ type: core.Output },],
    "initialized": [{ type: core.Output },],
    "moveNode": [{ type: core.Output },],
    "loadChildren": [{ type: core.Output },],
    "changeFilter": [{ type: core.Output },],
    "addNode": [{ type: core.Output },],
    "removeNode": [{ type: core.Output },],
    "className": [{ type: core.HostBinding, args: ['class.ngx-tree',] },],
    "loadingTemplate": [{ type: core.ContentChild, args: ['loadingTemplate',] },],
    "expanderTemplate": [{ type: core.ContentChild, args: ['expanderTemplate',] },],
    "treeNodeTemplate": [{ type: core.ContentChild, args: ['treeNodeTemplate',] },],
    "treeNodeWrapperTemplate": [{ type: core.ContentChild, args: ['treeNodeWrapperTemplate',] },],
    "treeNodeFullTemplate": [{ type: core.ContentChild, args: ['treeNodeFullTemplate',] },],
    "viewportComponent": [{ type: core.ViewChild, args: ['viewport',] },],
    "root": [{ type: core.ViewChild, args: ['root',] },],
    "onKeydown": [{ type: core.HostListener, args: ['body: keydown', ['$event'],] },],
    "onMousedown": [{ type: core.HostListener, args: ['body: mousedown', ['$event'],] },],
};
var DRAGGING_TARGET_CLASS = 'ngx-tree-dragging-target';
var TreeDragDirective = /** @class */ (function () {
    function TreeDragDirective(el, renderer, treeDraggingTargetService) {
        this.el = el;
        this.renderer = renderer;
        this.treeDraggingTargetService = treeDraggingTargetService;
    }
    TreeDragDirective.prototype.onDragStart = function (ev) {
        ev.dataTransfer.setData('text', this.draggingTarget.id);
        ev.dataTransfer.dropEffect = 'move';
        this.renderer.addClass(this.el.nativeElement, DRAGGING_TARGET_CLASS);
        this.treeDraggingTargetService.set(this.draggingTarget);
        if (this.draggingTarget.mouseAction) {
            this.draggingTarget.mouseAction('dragStart', ev);
        }
    };
    TreeDragDirective.prototype.onDragEnd = function (event) {
        if (this.draggingTarget.mouseAction) {
            this.draggingTarget.mouseAction('dragEnd', event);
        }
        this.renderer.removeClass(this.el.nativeElement, DRAGGING_TARGET_CLASS);
        this.treeDraggingTargetService.set(null);
    };
    TreeDragDirective.prototype.ngOnChanges = function (changes) {
        if ('treeDragEnabled' in changes) {
            this.renderer.setAttribute(this.el.nativeElement, 'draggable', this.treeDragEnabled ? 'true' : 'false');
        }
    };
    return TreeDragDirective;
}());
TreeDragDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[ngxTreeDrag]',
            },] },
];
TreeDragDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
    { type: TreeDraggingTargetService, },
]; };
TreeDragDirective.propDecorators = {
    "draggingTarget": [{ type: core.Input, args: ['ngxTreeDrag',] },],
    "treeDragEnabled": [{ type: core.Input },],
    "onDragStart": [{ type: core.HostListener, args: ['dragstart', ['$event'],] },],
    "onDragEnd": [{ type: core.HostListener, args: ['dragend', ['$event'],] },],
};
var DRAG_OVER_CLASS = 'is-dragging-over';
var DRAG_DISABLED_CLASS = 'is-dragging-over-disabled';
var TreeDropDirective = /** @class */ (function () {
    function TreeDropDirective(el, renderer, treeDraggedElement) {
        this.el = el;
        this.renderer = renderer;
        this.treeDraggedElement = treeDraggedElement;
        this.onDrop$ = new core.EventEmitter();
        this.onDragOver$ = new core.EventEmitter();
        this.onDragLeave$ = new core.EventEmitter();
        this.onDragEnter$ = new core.EventEmitter();
        this._allowDrop = function (element, $event) { return true; };
    }
    Object.defineProperty(TreeDropDirective.prototype, "treeAllowDrop", {
        get: function () {
            return this._allowDrop;
        },
        set: function (allowDrop) {
            this._allowDrop = isFunction(allowDrop) ? allowDrop : function (element, $event) { return allowDrop; };
        },
        enumerable: true,
        configurable: true
    });
    TreeDropDirective.prototype.ngOnDestroy = function () {
        this.onDrop$.complete();
        this.onDragEnter$.complete();
        this.onDragLeave$.complete();
        this.onDragOver$.complete();
    };
    TreeDropDirective.prototype.onDragOver = function ($event) {
        if (!this.allowDrop($event)) {
            return;
        }
        this.onDragOver$.emit({ event: $event, element: this.treeDraggedElement.get() });
        if (!this.dragOverClassAdded) {
            this.addClass();
        }
        this._stopEvent(event);
    };
    TreeDropDirective.prototype.onDragEnter = function ($event) {
        if (!this.allowDrop($event)) {
            this.addDisabledClass();
            return;
        }
        this.addClass();
        this.onDragEnter$.emit({ event: $event, element: this.treeDraggedElement.get() });
        this._stopEvent(event);
    };
    TreeDropDirective.prototype.onDragLeave = function ($event) {
        if (!this.allowDrop($event)) {
            this.removeDisabledClass();
            return;
        }
        this.removeClass();
        this.onDragLeave$.emit({ event: $event, element: this.treeDraggedElement.get() });
        this._stopEvent(event);
    };
    TreeDropDirective.prototype.onDrop = function ($event) {
        if (!this.allowDrop($event)) {
            return;
        }
        this.removeClass();
        this.onDrop$.emit({ event: $event, element: this.treeDraggedElement.get() });
        this.treeDraggedElement.set(null);
        this._stopEvent($event);
    };
    TreeDropDirective.prototype.allowDrop = function ($event) {
        return this._allowDrop(this.treeDraggedElement.get(), $event);
    };
    TreeDropDirective.prototype._stopEvent = function (event) {
        event.preventDefault();
        event.stopPropagation();
    };
    TreeDropDirective.prototype.addClass = function () {
        this.dragOverClassAdded = true;
        this.renderer.addClass(this.el.nativeElement, DRAG_OVER_CLASS);
    };
    TreeDropDirective.prototype.removeClass = function () {
        this.dragOverClassAdded = false;
        this.renderer.removeClass(this.el.nativeElement, DRAG_OVER_CLASS);
    };
    TreeDropDirective.prototype.addDisabledClass = function () {
        this.disabledClassAdded = true;
        this.renderer.addClass(this.el.nativeElement, DRAG_DISABLED_CLASS);
    };
    TreeDropDirective.prototype.removeDisabledClass = function () {
        this.disabledClassAdded = false;
        this.renderer.removeClass(this.el.nativeElement, DRAG_DISABLED_CLASS);
    };
    return TreeDropDirective;
}());
TreeDropDirective.decorators = [
    { type: core.Directive, args: [{
                selector: '[ngxTreeDrop]',
            },] },
];
TreeDropDirective.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: core.Renderer2, },
    { type: TreeDraggingTargetService, },
]; };
TreeDropDirective.propDecorators = {
    "onDrop$": [{ type: core.Output, args: ['ngxTreeDrop',] },],
    "onDragOver$": [{ type: core.Output, args: ['treeDropDragOver',] },],
    "onDragLeave$": [{ type: core.Output, args: ['treeDropDragLeave',] },],
    "onDragEnter$": [{ type: core.Output, args: ['treeDropDragEnter',] },],
    "treeAllowDrop": [{ type: core.Input },],
    "onDragOver": [{ type: core.HostListener, args: ['dragover', ['$event'],] },],
    "onDragEnter": [{ type: core.HostListener, args: ['dragenter', ['$event'],] },],
    "onDragLeave": [{ type: core.HostListener, args: ['dragleave', ['$event'],] },],
    "onDrop": [{ type: core.HostListener, args: ['drop', ['$event'],] },],
};
var NgxTreeModule = /** @class */ (function () {
    function NgxTreeModule() {
    }
    NgxTreeModule.forRoot = function () {
        return {
            ngModule: NgxTreeModule,
            providers: [
                TreeDraggingTargetService,
                {
                    provide: VIRTUAL_SCROLL_NODE_HEIGHT_QUOTA,
                    useValue: 5,
                },
            ],
        };
    };
    return NgxTreeModule;
}());
NgxTreeModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                ],
                declarations: [
                    TreeLoadingComponent,
                    TreeNodeComponent,
                    TreeComponent,
                    TreeNodeExpanderComponent,
                    TreeNodeWrapperComponent,
                    TreeNodeChildrenComponent,
                    TreeNodeContentComponent,
                    TreeViewportComponent,
                    TreeNodeDropSlotComponent,
                    TreeDragDirective,
                    TreeDropDirective,
                ],
                exports: [
                    TreeLoadingComponent,
                    TreeNodeComponent,
                    TreeComponent,
                    TreeNodeExpanderComponent,
                    TreeNodeWrapperComponent,
                    TreeNodeChildrenComponent,
                    TreeNodeContentComponent,
                    TreeViewportComponent,
                    TreeNodeDropSlotComponent,
                    TreeDragDirective,
                    TreeDropDirective,
                ],
            },] },
];
var _a;

exports.NgxTreeModule = NgxTreeModule;
exports.TreeLoadingComponent = TreeLoadingComponent;
exports.TreeNodeChildrenComponent = TreeNodeChildrenComponent;
exports.TreeNodeContentComponent = TreeNodeContentComponent;
exports.TreeNodeDropSlotComponent = TreeNodeDropSlotComponent;
exports.TreeNodeExpanderComponent = TreeNodeExpanderComponent;
exports.TreeNodeWrapperComponent = TreeNodeWrapperComponent;
exports.TreeNodeComponent = TreeNodeComponent;
exports.TreeViewportComponent = TreeViewportComponent;
exports.TreeComponent = TreeComponent;
exports.TreeDragDirective = TreeDragDirective;
exports.TreeDropDirective = TreeDropDirective;
exports.TreeDraggingTargetService = TreeDraggingTargetService;
exports.TreeVirtualScroll = TreeVirtualScroll;
exports.VIRTUAL_SCROLL_NODE_HEIGHT_QUOTA = VIRTUAL_SCROLL_NODE_HEIGHT_QUOTA;
exports.defaultUIOptions = defaultUIOptions;
exports.defaultDataOptions = defaultDataOptions;
exports.createTreeUIOptions = createTreeUIOptions;
exports.createTreeDataOptions = createTreeDataOptions;
exports.TreeModel = TreeModel;
exports.TreeNode = TreeNode;
exports.TREE_ACTIONS = TREE_ACTIONS;
exports.defaultActionMapping = defaultActionMapping;
exports.TREE_EVENTS = TREE_EVENTS;
exports.NUMBER_KEYS = NUMBER_KEYS;
exports.STRING_KEYS = STRING_KEYS;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=e-cloud-ngx-tree.umd.js.map
