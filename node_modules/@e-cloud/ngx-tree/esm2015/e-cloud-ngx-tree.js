import defaults from 'lodash-es/defaults';
import defaultsDeep from 'lodash-es/defaultsDeep';
import isNumber from 'lodash-es/isNumber';
import first from 'lodash-es/first';
import last from 'lodash-es/last';
import pullAt from 'lodash-es/pullAt';
import without from 'lodash-es/without';
import compact from 'lodash-es/compact';
import find from 'lodash-es/find';
import isFunction from 'lodash-es/isFunction';
import isString from 'lodash-es/isString';
import { Subject, BehaviorSubject, Subscription, merge } from 'rxjs';
import { ChangeDetectionStrategy, Component, HostBinding, Input, Inject, Injectable, InjectionToken, ElementRef, HostListener, Renderer2, ContentChild, EventEmitter, Output, ViewChild, Directive, NgModule } from '@angular/core';
import { filter, scan } from 'rxjs/operators';
import { animate, style, transition, trigger } from '@angular/animations';
import 'element-closest';
import each from 'lodash-es/each';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const NUMBER_KEYS = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    ENTER: 13,
    SPACE: 32,
};
const STRING_KEYS = {
    LEFT: 'ArrowLeft',
    UP: 'ArrowUp',
    RIGHT: 'ArrowRight',
    DOWN: 'ArrowDown',
    ENTER: 'Enter',
    SPACE: ' ',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const TREE_ACTIONS = {
    TOGGLE_SELECTED: (tree, node, $event) => node && node.toggleActivated(),
    TOGGLE_SELECTED_MULTI: (tree, node, $event) => node && node.toggleActivated(true),
    SELECT: (tree, node, $event) => node.setActive(true),
    DESELECT: (tree, node, $event) => node.setActive(false),
    FOCUS: (tree, node, $event) => node.focus(),
    TOGGLE_EXPANDED: (tree, node, $event) => {
        $event.stopPropagation();
        return node.hasChildren && node.toggleExpanded();
    },
    EXPAND: (tree, node, $event) => node.expand(),
    COLLAPSE: (tree, node, $event) => node.collapse(),
    DRILL_DOWN: (tree, node, $event) => tree.focusDrillDown(),
    DRILL_UP: (tree, node, $event) => tree.focusDrillUp(),
    NEXT_NODE: (tree, node, $event) => tree.focusNextNode(),
    PREVIOUS_NODE: (tree, node, $event) => tree.focusPreviousNode(),
    MOVE_NODE: (tree, node, $event, { from, to }) => {
        // default action assumes from = node, to = {parent, index}
        tree.moveNode(from, to);
    },
};
const defaultActionMapping = {
    mouse: {
        click: TREE_ACTIONS.TOGGLE_SELECTED,
        dblClick: null,
        contextMenu: null,
        expanderClick: TREE_ACTIONS.TOGGLE_EXPANDED,
        drop: TREE_ACTIONS.MOVE_NODE,
    },
    keys: {
        [NUMBER_KEYS.RIGHT]: TREE_ACTIONS.DRILL_DOWN,
        [NUMBER_KEYS.LEFT]: TREE_ACTIONS.DRILL_UP,
        [NUMBER_KEYS.DOWN]: TREE_ACTIONS.NEXT_NODE,
        [NUMBER_KEYS.UP]: TREE_ACTIONS.PREVIOUS_NODE,
        [NUMBER_KEYS.SPACE]: TREE_ACTIONS.TOGGLE_SELECTED,
        [NUMBER_KEYS.ENTER]: TREE_ACTIONS.TOGGLE_SELECTED,
    },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * common functions to handle tree actions
 * @record
 */

/**
 * a mapping model to link mouse events and keyboard events with actions
 * @record
 */

/**
 * @record
 */

const defaultUIOptions = {
    allowDrag: false,
    allowDrop: false,
    levelPadding: () => '0px',
    useVirtualScroll: false,
    nodeClass: () => '',
};
const defaultDataOptions = {
    childrenField: 'children',
    displayField: 'name',
    idField: 'id',
    isExpandedField: 'isExpanded',
    actionMapping: defaultActionMapping,
    getChildren: (node) => null,
};
/**
 * @record
 */

/**
 * @record
 */

/**
 * create tree options about UI with defaults
 * @param {?=} rawOpts
 * @return {?}
 */
function createTreeUIOptions(rawOpts = {}) {
    const /** @type {?} */ levelPaddingOpt = rawOpts.levelPadding;
    if (isNumber(levelPaddingOpt)) {
        rawOpts.levelPadding = function (node) {
            return (levelPaddingOpt + levelPaddingOpt * (node.level - 1)) + 'px';
        };
    }
    return defaults({}, rawOpts, defaultUIOptions);
}
/**
 * @record
 */

/**
 * create tree options about data with defaults
 * @param {?=} rawOpts
 * @return {?}
 */
function createTreeDataOptions(rawOpts = {}) {
    return defaultsDeep({}, rawOpts, defaultDataOptions);
}
// export const TREE_DATA_OPTIONS = new InjectionToken('TREE_DATA_OPTIONS')

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const TREE_EVENTS = {
    expand: 'expand',
    collapse: 'collapse',
    toggleExpander: 'toggleExpander',
    activate: 'activate',
    deactivate: 'deactivate',
    focus: 'focus',
    blur: 'blur',
    initialized: 'initialized',
    moveNode: 'moveNode',
    loadChildren: 'loadChildren',
    changeFilter: 'changeFilter',
    removeNode: 'removeNode',
    addNode: 'addNode',
};
/**
 * all events that the tree will trigger
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TreeNode {
    /**
     * @param {?} data
     * @param {?} parent
     * @param {?} treeModel
     * @param {?} index
     */
    constructor(data, parent, treeModel, index) {
        this.data = data;
        this.parent = parent;
        this.treeModel = treeModel;
        this.index = index;
        /**
         * top edge position relative to the top edge of scroll area
         */
        this.position = 0;
        /**
         * the visual height of the node
         */
        this.height = 0;
        this.loadingChildren = false;
        // Make sure there's a unique id without overriding existing ids to work with immutable data structures
        if (this.id === undefined || this.id === null) {
            this.id = uuid();
        }
        treeModel.addCache(this);
        if (data[this.options.isExpandedField]) {
            treeModel.setExpandedNodeInPlace(this);
        }
        if (this.getField('children')) {
            this.initChildren();
        }
    }
    /**
     * @return {?}
     */
    get isHidden() {
        return this.treeModel.isNodeHidden(this);
    }
    /**
     * @return {?}
     */
    get isExpanded() {
        return this.treeModel.isNodeExpanded(this);
    }
    /**
     * @return {?}
     */
    get isCollapsed() {
        return !this.isExpanded;
    }
    /**
     * @return {?}
     */
    get isActive() {
        return this.treeModel.isNodeActive(this);
    }
    /**
     * @return {?}
     */
    get isFocused() {
        return this.treeModel.isNodeFocused(this);
    }
    /**
     * @return {?}
     */
    get isLeaf() {
        return !this.hasChildren;
    }
    /**
     * @return {?}
     */
    get isRoot() {
        return this.parent === null;
    }
    /**
     * Level in the tree (starts from 1).
     * @return {?}
     */
    get level() {
        return this.parent ? this.parent.level + 1 : 0;
    }
    /**
     * Path in the tree: Array of IDs.
     * @return {?}
     */
    get path() {
        return this.parent ? [...this.parent.path, this.id] : [];
    }
    /**
     * @return {?}
     */
    get hasChildren() {
        return !!(this.data.hasChildren || (this.children && this.children.length > 0));
    }
    /**
     * @return {?}
     */
    get hasVisibleChildren() {
        return !!(this.data.hasChildren || (this.visibleChildren && this.visibleChildren.length > 0));
    }
    /**
     * @return {?}
     */
    get options() {
        return this.treeModel.options;
    }
    /**
     * The value of the node's field that is used for displaying its content.
     * By default 'name', unless stated otherwise in the options
     * @return {?}
     */
    get displayField() {
        return this.getField('display');
    }
    /**
     * A unique key of this node among its siblings.
     * By default it's the 'id' of the original node, unless stated otherwise in options.idField
     * @return {?}
     */
    get id() {
        return this.getField('id');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this.setField('id', value);
    }
    /**
     * @return {?}
     */
    get visibleChildren() {
        return (this.children || []).filter((node) => !node.isHidden);
    }
    /**
     * Fire an event to the renderer of the tree (if it was registered)
     * @param {?} event
     * @return {?}
     */
    fireEvent(event) {
        this.treeModel.fireEvent(event);
    }
    /**
     * @param {?} key
     * @return {?}
     */
    getField(key) {
        return this.data[this.options[`${key}Field`]];
    }
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setField(key, value) {
        this.data[this.options[`${key}Field`]] = value;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDrop($event) {
        this.mouseAction('drop', $event.event, {
            from: $event.element,
            to: { parent: this, index: 0, dropOnNode: true },
        });
    }
    /**
     * @param {?} steps
     * @param {?=} skipHidden
     * @return {?}
     */
    findAdjacentSibling(steps, skipHidden = false) {
        return this.getParentChildren(skipHidden)[this.index + steps];
    }
    /**
     * @param {?=} skipHidden whether to skip hidden nodes
     * @return {?} next sibling (or null)
     */
    findNextSibling(skipHidden = false) {
        return this.findAdjacentSibling(+1, skipHidden);
    }
    /**
     * @param {?=} skipHidden whether to skip hidden nodes
     * @return {?} previous sibling (or null)
     */
    findPreviousSibling(skipHidden = false) {
        return this.findAdjacentSibling(-1, skipHidden);
    }
    /**
     * @param {?=} skipHidden whether to skip hidden nodes
     * @return {?} first child (or null)
     */
    getFirstChild(skipHidden = false) {
        const /** @type {?} */ children = skipHidden ? this.visibleChildren : this.children;
        return first(children || []);
    }
    /**
     * @param {?=} skipHidden whether to skip hidden nodes
     * @return {?} last child (or null)
     */
    getLastChild(skipHidden = false) {
        const /** @type {?} */ children = skipHidden ? this.visibleChildren : this.children;
        return last(children || []);
    }
    /**
     * Finds the visually next node in the tree.
     * @param {?=} goInside whether to look for children or just siblings
     * @param {?=} skipHidden
     * @return {?} next node.
     */
    findNextNode(goInside = true, skipHidden = false) {
        return goInside && this.isExpanded && this.getFirstChild(skipHidden) ||
            this.findNextSibling(skipHidden) ||
            this.parent && this.parent.findNextNode(false, skipHidden);
    }
    /**
     * Finds the visually previous node in the tree.
     * @param {?=} skipHidden whether to skip hidden nodes
     * @return {?} previous node.
     */
    findPreviousNode(skipHidden = false) {
        const /** @type {?} */ previousSibling = this.findPreviousSibling(skipHidden);
        if (!previousSibling) {
            return this.parent;
        }
        return previousSibling.getLastOpenDescendant(skipHidden);
    }
    /**
     * @param {?} node
     * @return {?} true if this node is a descendant of the parameter node
     */
    isDescendantOf(node) {
        if (this === node) {
            return true;
        }
        else {
            return this.parent && this.parent.isDescendantOf(node);
        }
    }
    /**
     * @return {?}
     */
    loadChildren() {
        if (!this.options.getChildren) {
            return Promise.resolve(); // Not getChildren method - for using redux
        }
        this.loadingChildren = true;
        return Promise.resolve(this.options.getChildren(this))
            .then((children) => {
            if (children) {
                this.setField('children', children);
                this.initChildren();
            }
        })
            .then(() => {
            this.loadingChildren = false;
            this.fireEvent({
                eventName: TREE_EVENTS.loadChildren,
                node: this,
            });
        });
    }
    /**
     * Expands the node
     * @return {?}
     */
    expand() {
        if (!this.isExpanded) {
            return this.toggleExpanded();
        }
        return Promise.resolve();
    }
    /**
     * Collapses the node
     * @return {?}
     */
    collapse() {
        if (this.isExpanded) {
            this.toggleExpanded();
        }
        return this;
    }
    /**
     * Invokes a method for every node under this one - depth first
     * @param {?} fn  a function that receives the node
     * @return {?}
     */
    traverse(fn) {
        Promise.resolve(fn(this)).then(() => {
            if (this.children) {
                this.children.forEach((child) => child.traverse(fn));
            }
        });
    }
    /**
     * expand all nodes under this one
     * @return {?}
     */
    expandAll() {
        this.traverse((node) => node.expand());
    }
    /**
     * collapse all nodes under this one
     * @return {?}
     */
    collapseAll() {
        this.traverse((node) => node.collapse());
    }
    /**
     * Expands / Collapses the node
     * @param {?=} isExpanded
     * @return {?}
     */
    toggleExpanded(isExpanded = !this.isExpanded) {
        if (this.hasChildren) {
            this.treeModel.setExpandedNode(this, isExpanded);
            if (!this.children && this.hasChildren && isExpanded) {
                return this.loadChildren();
            }
        }
        return Promise.resolve();
    }
    /**
     * @param {?=} isActive
     * @param {?=} isMulti
     * @return {?}
     */
    setActive(isActive = true, isMulti = false) {
        this.treeModel.setActiveNode(this, isActive, isMulti);
        return this;
    }
    /**
     * @param {?=} isHidden  if true makes the node hidden, otherwise visible
     * @return {?}
     */
    setHidden(isHidden = true) {
        this.treeModel.setHiddenNode(this, isHidden);
        return this;
    }
    /**
     * Activates / Deactivates the node (selects / deselects)
     * @param {?=} isMulti
     * @return {?}
     */
    toggleActivated(isMulti = false) {
        this.setActive(!this.isActive, isMulti);
        return this;
    }
    /**
     * @param {?=} isMulti
     * @return {?}
     */
    setActiveAndVisible(isMulti = false) {
        this.setActive(true, isMulti)
            .ensureVisible();
        this.scrollIntoView();
        return this;
    }
    /**
     * Expands all ancestors of the node
     * @return {?}
     */
    ensureVisible() {
        if (this.parent) {
            this.parent.expand();
            this.parent.ensureVisible();
        }
        return this;
    }
    /**
     * @param {?=} force
     * @param {?=} scrollToMiddle
     * @return {?}
     */
    scrollIntoView(force = false, scrollToMiddle) {
        this.treeModel.scrollIntoView(this, force, scrollToMiddle);
    }
    /**
     * Focus on the node
     * @param {?=} scroll
     * @return {?}
     */
    focus(scroll = true) {
        const /** @type {?} */ previousNode = this.treeModel.focusedNode;
        this.treeModel.setFocusedNode(this);
        if (scroll) {
            this.scrollIntoView();
        }
        if (previousNode) {
            this.fireEvent({ eventName: TREE_EVENTS.blur, node: previousNode });
        }
        this.fireEvent({ eventName: TREE_EVENTS.focus, node: this });
        return this;
    }
    /**
     * Blur (unfocus) the node
     * @return {?}
     */
    blur() {
        const /** @type {?} */ previousNode = this.treeModel.focusedNode;
        this.treeModel.setFocusedNode(null);
        if (previousNode) {
            this.fireEvent({ eventName: TREE_EVENTS.blur, node: this });
        }
        return this;
    }
    /**
     * Hides the node
     * @return {?}
     */
    hide() {
        this.setHidden(true);
        return this;
    }
    /**
     * Makes the node visible
     * @return {?}
     */
    show() {
        this.setHidden(false);
        return this;
    }
    /**
     * @param {?} data
     * @param {?} index
     * @return {?}
     */
    addChild(data, index) {
        const /** @type {?} */ node = new TreeNode(data, this, this.treeModel, index);
        // If node doesn't have children - create children array
        if (!this.getField('children')) {
            this.setField('children', []);
        }
        if (this.children) {
            this.getField('children').splice(index, 0, data);
            this.children.splice(index, 0, node);
            this.children = this.children.slice();
        }
        else {
            this.getField('children').push(data);
            this.children = [node];
        }
        this.reCalcChildrenIndices(index);
        this.fireEvent({ eventName: TREE_EVENTS.addNode, node });
    }
    /**
     * @param {?} data
     * @return {?}
     */
    appendChild(data) {
        this.addChild(data, this.children ? this.children.length : 0);
    }
    /**
     * @return {?}
     */
    remove() {
        this.parent.removeChild(this);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    removeChild(node) {
        pullAt(this.getField('children'), node.index);
        this.children = without(this.children, node);
        this.reCalcChildrenIndices(0);
        this.fireEvent({ eventName: TREE_EVENTS.removeNode, node });
        if (node.isFocused) {
            this.treeModel.setFocusedNode(null);
            this.treeModel.setActiveNode(node, false);
        }
        if (node.isExpanded) {
            this.treeModel.setExpandedNodeInPlace(node, false);
        }
        node.treeModel = null;
        node.elementRef = null;
    }
    /**
     * @param {?} actionName
     * @param {?} $event
     * @param {?=} data
     * @return {?}
     */
    mouseAction(actionName, $event, data = null) {
        this.treeModel.setFocus(true);
        const /** @type {?} */ actionMapping = this.options.actionMapping.mouse;
        const /** @type {?} */ action = actionMapping[actionName];
        if (action) {
            action(this.treeModel, this, $event, data);
        }
    }
    /**
     * @param {?} offset
     * @return {?}
     */
    reCalcChildrenIndices(offset) {
        this.children.slice(offset).forEach((child, index) => {
            child.index = index + offset;
        });
    }
    /**
     * @return {?}
     */
    initChildren() {
        this.children = this.getField('children')
            .map((data, index) => new TreeNode(data, this, this.treeModel, index));
    }
    /**
     * @param {?=} skipHidden
     * @return {?}
     */
    getLastOpenDescendant(skipHidden = false) {
        const /** @type {?} */ lastChild = this.getLastChild(skipHidden);
        return (this.isCollapsed || !lastChild)
            ? this
            : lastChild.getLastOpenDescendant(skipHidden);
    }
    /**
     * @param {?=} skipHidden
     * @return {?}
     */
    getParentChildren(skipHidden = false) {
        return this.parent
            ? (skipHidden ? this.parent.visibleChildren : this.parent.children)
            : [];
    }
}
let _uuid = 0;
/**
 * @return {?}
 */
function uuid() {
    return `ngx-tid-${_uuid++}`;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

class TreeModel {
    /**
     * @param {?} nodes
     * @param {?} events
     * @param {?=} options
     */
    constructor(nodes, events, options) {
        this.nodes = nodes;
        this.events = events;
        this.options = options;
        this.scrollIntoView$ = new Subject();
        this.focusedNodeId = null;
        this.expandedNodeIds = new Map();
        this.activeNodeIds = new Map();
        this.hiddenNodeIds = new Map();
        this.nodeCache = new Map();
        this.options = createTreeDataOptions(options);
        const /** @type {?} */ virtualRootConfig = {
            virtual: true,
            // todo: determine to use fixed children field later
            [this.options.childrenField]: this.nodes,
        };
        this.virtualRoot = new TreeNode(virtualRootConfig, null, this, 0);
        this.setExpandedNodeInPlace(this.virtualRoot);
        this.roots = this.virtualRoot.children;
    }
    /**
     * Is the tree currently focused
     * @return {?}
     */
    get isFocused() {
        return TreeModel.focusedTree === this;
    }
    /**
     * if the tree is empty
     * @return {?}
     */
    get isEmptyTree() {
        return this.roots && this.roots.length === 0;
    }
    /**
     * Current focused node
     * @return {?}
     */
    get focusedNode() {
        return this.focusedNodeId ? this.getNodeById(this.focusedNodeId) : null;
    }
    /**
     * @return {?} Current expanded nodes
     */
    get expandedNodes() {
        const /** @type {?} */ nodes = Array.from(this.expandedNodeIds.keys())
            .filter((id) => this.expandedNodeIds.get(id))
            .map((id) => this.getNodeById(id));
        return compact(nodes);
    }
    /**
     * @return {?} Current active (selected) nodes
     */
    get activeNodes() {
        const /** @type {?} */ nodes = Array.from(this.activeNodeIds.keys())
            .filter((id) => this.activeNodeIds.get(id))
            .map((id) => this.nodeCache.get(id));
        return compact(nodes);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    addCache(node) {
        this.nodeCache.set(node.id, node);
    }
    /**
     * @param {?} options
     * @return {?}
     */
    updateOptions(options) {
        this.options = options;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    fireEvent(event) {
        // event.treeModel = this
        this.events[event.eventName].emit(event);
    }
    /**
     * @param {?} eventName
     * @param {?} fn
     * @return {?}
     */
    subscribe(eventName, fn) {
        return this.events[eventName].subscribe(fn);
    }
    /**
     * @return {?} Current active (selected) node. If multiple nodes are active - returns the first one.
     */
    getActiveNode() {
        return this.activeNodes[0];
    }
    /**
     * @return {?} All root nodes that pass the current filter
     */
    getVisibleRoots() {
        return this.virtualRoot.visibleChildren;
    }
    /**
     * @param {?=} skipHidden  true or false - whether to skip hidden nodes
     * @return {?} first root of the tree
     */
    getFirstRoot(skipHidden = false) {
        return first(skipHidden ? this.getVisibleRoots() : this.roots);
    }
    /**
     * @param {?=} skipHidden  true or false - whether to skip hidden nodes
     * @return {?} last root of the tree
     */
    getLastRoot(skipHidden = false) {
        return last(skipHidden ? this.getVisibleRoots() : this.roots);
    }
    /**
     * @param {?} path  array of node IDs to be traversed respectively
     * @param {?=} startNode  optional. Which node to start traversing from
     * @return {?} The node, if found - null otherwise
     */
    getNodeByPath(path, startNode = null) {
        if (!path) {
            return null;
        }
        startNode = startNode || this.virtualRoot;
        if (path.length === 0) {
            return startNode;
        }
        if (!startNode.children) {
            return null;
        }
        const /** @type {?} */ childId = path.shift();
        const /** @type {?} */ childNode = find(startNode.children, /** @type {?} */ ({ id: childId }));
        if (!childNode) {
            return null;
        }
        return this.getNodeByPath(path, childNode);
    }
    /**
     * @param {?} id  node ID to find
     * @return {?} The node, if found - null otherwise
     */
    getNodeById(id) {
        return this.nodeCache.get(id);
    }
    /**
     * @param {?} predicate - either an object or a function, used as a test condition on all nodes.
     *            Could be every predicate that's supported by lodash's `find` method
     * @param {?=} startNode  optional. Which node to start traversing from
     * @return {?} First node that matches the predicate, if found - null otherwise
     */
    getNodeBy(predicate, startNode = null) {
        // todo: refactor to a loop
        startNode = startNode || this.virtualRoot;
        if (!startNode.children) {
            return null;
        }
        const /** @type {?} */ found = find(startNode.children, predicate);
        if (found) {
            // found in children
            return found;
        }
        else {
            // look in children's children
            for (const /** @type {?} */ child of startNode.children) {
                const /** @type {?} */ foundInChildren = this.getNodeBy(predicate, child);
                if (foundInChildren) {
                    return foundInChildren;
                }
            }
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isNodeExpanded(node) {
        return !!this.expandedNodeIds.get(node.id);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isNodeHidden(node) {
        return !!this.hiddenNodeIds.get(node.id);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isNodeActive(node) {
        return !!this.activeNodeIds.get(node.id);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    isNodeFocused(node) {
        return this.focusedNode === node;
    }
    /**
     * @param {?} node
     * @param {?} isActive
     * @param {?=} isMulti
     * @return {?}
     */
    setActiveNode(node, isActive, isMulti = false) {
        if (isMulti) {
            this.setMultiActiveNodes(node, isActive);
        }
        else {
            this.setSingleActiveNode(node, isActive);
        }
        if (isActive) {
            node.focus();
            this.fireEvent({ eventName: TREE_EVENTS.activate, node });
        }
        else {
            this.fireEvent({ eventName: TREE_EVENTS.deactivate, node });
        }
    }
    /**
     * @param {?} node
     * @param {?=} isExpanded
     * @return {?}
     */
    setExpandedNodeInPlace(node, isExpanded = true) {
        this.expandedNodeIds.set(node.id, isExpanded);
    }
    /**
     * @param {?} node
     * @param {?=} isExpanded
     * @return {?}
     */
    setExpandedNode(node, isExpanded = true) {
        this.expandedNodeIds.set(node.id, isExpanded);
        if (isExpanded) {
            this.fireEvent({ eventName: TREE_EVENTS.expand, node });
        }
        else {
            this.fireEvent({ eventName: TREE_EVENTS.collapse, node });
        }
        this.fireEvent({ eventName: TREE_EVENTS.toggleExpander, node, isExpanded });
    }
    /**
     * @param {?} node
     * @param {?=} isHidden
     * @return {?}
     */
    setHiddenNode(node, isHidden = true) {
        this.hiddenNodeIds.set(node.id, isHidden);
    }
    /**
     * Set focus on a node
     * @param {?} node
     * @return {?}
     */
    setFocusedNode(node) {
        this.focusedNodeId = node ? node.id : null;
    }
    /**
     * Focuses or blurs the tree
     * @param {?} value  true or false - whether to set focus or blur.
     * @return {?}
     */
    setFocus(value) {
        TreeModel.focusedTree = value ? this : null;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    traverse(fn) {
        this.roots.forEach((root) => root.traverse(fn));
    }
    /**
     * @param {?} id
     * @return {?}
     */
    activateNode(id) {
        const /** @type {?} */ target = this.getNodeById(id);
        if (target) {
            target.setActiveAndVisible();
            return true;
        }
        return false;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    focusNode(id) {
        const /** @type {?} */ target = this.getNodeById(id);
        if (target) {
            target.focus();
            return true;
        }
        return false;
    }
    /**
     * Focuses on the next node in the tree (same as down arrow)
     * @return {?}
     */
    focusNextNode() {
        const /** @type {?} */ previousNode = this.focusedNode;
        const /** @type {?} */ nextNode = previousNode ? previousNode.findNextNode(true, true) : this.getFirstRoot(true);
        if (nextNode) {
            nextNode.focus();
        }
    }
    /**
     * Focuses on the previous node in the tree (same as up arrow)
     * @return {?}
     */
    focusPreviousNode() {
        const /** @type {?} */ previousNode = this.focusedNode;
        const /** @type {?} */ nextNode = previousNode ? previousNode.findPreviousNode(true) : this.getLastRoot(true);
        if (nextNode) {
            nextNode.focus();
        }
    }
    /**
     * Focuses on the inner child of the current focused node (same as right arrow on an expanded node)
     * @return {?}
     */
    focusDrillDown() {
        const /** @type {?} */ previousNode = this.focusedNode;
        if (previousNode && previousNode.isCollapsed && previousNode.hasChildren) {
            previousNode.toggleExpanded();
        }
        else {
            const /** @type {?} */ nextNode = previousNode ? previousNode.getFirstChild(true) : this.getFirstRoot(true);
            if (nextNode) {
                nextNode.focus();
            }
        }
    }
    /**
     * Focuses on the parent of the current focused node (same as left arrow on a collapsed node)
     * @return {?}
     */
    focusDrillUp() {
        const /** @type {?} */ previousNode = this.focusedNode;
        if (!previousNode) {
            return;
        }
        if (previousNode.isExpanded) {
            previousNode.toggleExpanded();
        }
        else {
            const /** @type {?} */ nextNode = previousNode.parent;
            if (nextNode) {
                nextNode.focus();
            }
        }
    }
    /**
     * expand all nodes
     * @return {?}
     */
    expandAll() {
        this.roots.forEach((root) => root.expandAll());
    }
    /**
     * collapse all nodes
     * @return {?}
     */
    collapseAll() {
        this.roots.forEach((root) => root.collapseAll());
    }
    /**
     * @param {?} node
     * @param {?} $event
     * @return {?}
     */
    performKeyAction(node, $event) {
        // todo: the keyCode is deprecated on MDN, replace it some day
        const /** @type {?} */ action = this.options.actionMapping.keys[$event.keyCode];
        if (action) {
            $event.preventDefault();
            action(this, node, $event);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Marks isHidden field in all nodes recursively according to the filter param.
     * If a node is marked visible, all of its ancestors will be marked visible as well.
     * @param {?} filter  either a string or a function.
     *   In case it's a string, it will be searched case insensitively in the node's display attribute
     *   In case it's a function, it will be passed the node, and should return true if the node should be visible,
     *     false otherwise
     * @param {?=} autoShow  if true, make sure all nodes that passed the filter are visible
     * @return {?}
     */
    filterNodes(filter$$1, autoShow = true) {
        let /** @type {?} */ filterFn;
        if (!filter$$1) {
            return this.clearFilter();
        }
        // support function and string filter
        if (isString(filter$$1)) {
            filterFn = (node) => node.displayField.toLowerCase().includes(filter$$1.toLowerCase());
        }
        else if (isFunction(filter$$1)) {
            filterFn = filter$$1;
        }
        else {
            throw new TypeError(`Don't know what to do with filter: ${filter$$1}. It should be either a string or function`);
        }
        const /** @type {?} */ ids = new Map();
        this.roots.forEach((node) => this.filterNode(ids, node, filterFn, autoShow));
        this.hiddenNodeIds = ids;
        this.fireEvent({ eventName: TREE_EVENTS.changeFilter });
    }
    /**
     * Marks all nodes isHidden = false
     * @return {?}
     */
    clearFilter() {
        this.hiddenNodeIds = new Map();
        this.fireEvent({ eventName: TREE_EVENTS.changeFilter });
    }
    /**
     * moves a node from one location in the tree to another
     * @param {?} node location has a from and a to attributes, each has a node and index attributes.
     * The combination of node + index tells which node needs to be moved, and to where
     * @param {?} to
     * @return {?}
     */
    moveNode(node, to) {
        const /** @type {?} */ fromIndex = node.index;
        const /** @type {?} */ fromParent = node.parent;
        if (!canMoveNode(node, fromIndex, to)) {
            return;
        }
        node.remove();
        // Compensate for index if already removed from parent:
        const /** @type {?} */ toIndex = (fromParent === to.parent && to.index > fromIndex) ? to.index - 1 : to.index;
        if (to.dropOnNode) {
            to.parent.appendChild(node.data);
        }
        else {
            to.parent.addChild(node.data, toIndex);
        }
        this.fireEvent({
            eventName: TREE_EVENTS.moveNode,
            node,
            to: { parent: to.parent.data, index: toIndex },
        });
    }
    /**
     * @param {?} node
     * @param {?} force
     * @param {?} scrollToMiddle
     * @return {?}
     */
    scrollIntoView(node, force, scrollToMiddle) {
        this.scrollIntoView$.next({
            node, force, scrollToMiddle,
        });
    }
    /**
     * @param {?} ids
     * @param {?} node
     * @param {?} filterFn
     * @param {?} autoExpand
     * @return {?}
     */
    filterNode(ids, node, filterFn, autoExpand) {
        // if node passes function then it's visible
        let /** @type {?} */ isVisible = filterFn(node);
        if (node.children) {
            // if one of node's children passes filter then this node is also visible
            node.children.forEach((child) => {
                if (this.filterNode(ids, child, filterFn, autoExpand)) {
                    isVisible = true;
                }
            });
        }
        // mark node as hidden
        if (!isVisible) {
            ids.set(node.id, true);
        }
        // auto expand parents to make sure the filtered nodes are visible
        if (autoExpand && isVisible) {
            node.ensureVisible();
        }
        return isVisible;
    }
    /**
     * @param {?} node
     * @param {?} active
     * @return {?}
     */
    setSingleActiveNode(node, active) {
        // Deactivate all other nodes:
        this.activeNodes
            .filter((activeNode) => activeNode !== node)
            .forEach((activeNode) => {
            this.fireEvent({ eventName: TREE_EVENTS.deactivate, node: activeNode });
        });
        if (active) {
            this.activeNodeIds = new Map([[node.id, true]]);
        }
        else {
            this.activeNodeIds = new Map();
        }
    }
    /**
     * @param {?} node
     * @param {?} active
     * @return {?}
     */
    setMultiActiveNodes(node, active) {
        this.activeNodeIds.set(node.id, active);
    }
}
/**
 * static cache for recording the tree model while using multiple tree component in same container.
 */
TreeModel.focusedTree = null;
/**
 * @param {?} node
 * @param {?} fromIndex
 * @param {?} to
 * @return {?}
 */
function canMoveNode(node, fromIndex, to) {
    // same node:
    if (node.parent === to.parent && fromIndex === to.index) {
        return false;
    }
    return !to.parent.isDescendantOf(node);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TreeLoadingComponent {
    constructor() {
        this.className = true;
    }
}
TreeLoadingComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-tree-loading',
                template: `<span *ngIf="!template">loading...</span>

<ng-container
  [ngTemplateOutlet]="template"
  [ngTemplateOutletContext]="{ $implicit: null, node: node }">
</ng-container>
`,
                styles: [`:host{white-space:nowrap}`],
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
TreeLoadingComponent.propDecorators = {
    "template": [{ type: Input },],
    "node": [{ type: Input },],
    "className": [{ type: HostBinding, args: ['class.tree-loading',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const Y_OFFSET_NODE_SIZE = 3;
let id = 0;
const VIRTUAL_SCROLL_NODE_HEIGHT_QUOTA = new InjectionToken('VIRTUAL_SCROLL_NODE_HEIGHT_QUOTA');
class TreeVirtualScroll {
    /**
     * @param {?} quota
     */
    constructor(quota) {
        this.quota = quota;
        this.averageNodeHeight = 0;
        this.hasEnoughNodeHeight = false;
        this.lastScrollTop = 0;
        this.disabled = false;
        this.collectionMonitor$ = new BehaviorSubject(null);
        this.nodeHeightAnalytics$ = new Subject();
        this.id = id++;
        this.collectAverageNodeHeight();
    }
    /**
     * @param {?} viewport
     * @param {?} scrollTop
     * @return {?}
     */
    adjustViewport(viewport, scrollTop) {
        this.lastScrollTop = scrollTop;
        this.currentViewport = viewport;
        const /** @type {?} */ Y_OFFSET = this.averageNodeHeight * Y_OFFSET_NODE_SIZE;
        const /** @type {?} */ startPos = scrollTop > Y_OFFSET ? scrollTop - Y_OFFSET : 0;
        const /** @type {?} */ endPos = viewport.height + scrollTop + Y_OFFSET;
        this.collectionMonitor$.next({
            startPos,
            endPos,
        });
    }
    /**
     * @param {?} observer
     * @return {?}
     */
    waitForCollection(observer) {
        return this.collectionMonitor$
            .pipe(filter(val => !!val))
            .subscribe(observer);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    reportNodeHeight(data) {
        this.nodeHeightAnalytics$.next(data);
    }
    /**
     * @param {?} treeModel
     * @return {?}
     */
    reCalcPositions(treeModel) {
        // here we reset the root nodes' positions to properly recalculate the positions
        // after some actions like filter
        treeModel.roots.forEach(node => {
            node.position = 0;
        });
        treeModel.virtualRoot.height = this.getPositionAfter(treeModel.getVisibleRoots(), 0);
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabled(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @return {?}
     */
    isDisabled() {
        return this.disabled;
    }
    /**
     * @param {?} node
     * @param {?} force
     * @param {?=} scrollToMiddle
     * @return {?}
     */
    scrollIntoView(node, force, scrollToMiddle = true) {
        if (force || // force scroll to node
            // force scroll to node
            node.position < this.lastScrollTop || // node is above viewport
            // node is above viewport
            node.position + this.averageNodeHeight > this.lastScrollTop + this.currentViewport.height) {
            // node is below viewport
            return scrollToMiddle ? node.position - this.currentViewport.height / 2 + this.averageNodeHeight : // scroll to middle
                node.position; // scroll to start
        }
        return null;
    }
    /**
     * @param {?} nodes
     * @param {?} startPos
     * @return {?}
     */
    getPositionAfter(nodes, startPos) {
        let /** @type {?} */ position = startPos;
        nodes.forEach((node) => {
            node.position = position;
            // as node is hidden, it should play as a shadow node for it next sibling node for
            // the proper position splitting
            position = this.getPositionAfterNode(node, node.position, node.isHidden);
        });
        return position;
    }
    /**
     * @param {?} node
     * @param {?} startPos
     * @param {?=} isPrevShadow
     * @return {?}
     */
    getPositionAfterNode(node, startPos, isPrevShadow = false) {
        let /** @type {?} */ position = isPrevShadow ? startPos : this.averageNodeHeight + startPos;
        if (node.children && node.isExpanded) {
            // TBD: consider loading component as well
            position = this.getPositionAfter(node.visibleChildren, position);
        }
        // todo: here we assume the loading component's height is the same as averageNodeHeight
        node.height = position - startPos + (node.loadingChildren ? this.averageNodeHeight : 0);
        return position;
    }
    /**
     * @return {?}
     */
    collectAverageNodeHeight() {
        this.nodeHeightAnalytics$
            .pipe(scan((acc, cur) => {
            const /** @type {?} */ lastAvg = acc[0] / acc[1];
            const /** @type {?} */ sum = cur + acc[0];
            const /** @type {?} */ count = acc[1] + 1;
            const /** @type {?} */ avg = sum / count;
            if (avg / lastAvg > 1.5 || lastAvg / avg > 1.5) {
                return [cur, 1];
            }
            return [sum, count];
        }, [0, 0]))
            .subscribe(pair => {
            this.averageNodeHeight = pair[0] / pair[1];
            if (pair[1] >= this.quota) {
                this.hasEnoughNodeHeight = true;
            }
        });
    }
}
TreeVirtualScroll.decorators = [
    { type: Injectable },
];
/** @nocollapse */
TreeVirtualScroll.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [VIRTUAL_SCROLL_NODE_HEIGHT_QUOTA,] },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * a binary search function
 * @template T
 * @param {?} nodes
 * @param {?} condition
 * @param {?=} firstIndex
 * @return {?}
 */
function binarySearch(nodes, condition, firstIndex = 0) {
    let /** @type {?} */ left = firstIndex;
    let /** @type {?} */ right = nodes.length - 1;
    while (left !== right) {
        const /** @type {?} */ mid = Math.floor((left + right) / 2);
        if (condition(nodes[mid])) {
            right = mid;
        }
        else {
            if (left === mid) {
                left = right;
            }
            else {
                left = mid;
            }
        }
    }
    return left;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Time and timing curve for expansion panel animations.
 */
const EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';
class TreeNodeChildrenComponent {
    /**
     * @param {?} virtualScroll
     */
    constructor(virtualScroll) {
        this.virtualScroll = virtualScroll;
        this.marginTop = 0;
        this.viewportNodes = [];
        this.disableMarginTop = false;
        this.refreshTree = false;
        this.expandAnimation = true;
        this.className = true;
        this.scrollSub = Subscription.EMPTY;
    }
    /**
     * @return {?}
     */
    get noPadding() {
        return !this.options.levelPadding;
    }
    /**
     * @return {?}
     */
    get marginTopAttr() {
        return this.disableMarginTop ? 0 : this.marginTop;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.viewportNodes = this.children;
        this.scrollSub = this.virtualScroll.waitForCollection((metrics) => {
            if (this.node.treeModel && this.node.isExpanded) {
                // here we directly access node's visibleChildren but not component's `children`
                // property is, because it will only be updated on next lifecycle check, which is
                // after the collection notification
                this.viewportNodes = this.getViewportNodes(this.node.visibleChildren, metrics);
                this.marginTop = this.calcMarginTop();
            }
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('children' in changes && changes["children"].currentValue) {
            this.viewportNodes = this.virtualScroll.isDisabled() || this.refreshTree
                ? this.children : this.viewportNodes;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.scrollSub.unsubscribe();
    }
    /**
     * @param {?} index
     * @param {?} node
     * @return {?}
     */
    trackNode(index, node) {
        return node.id;
    }
    /**
     * @return {?}
     */
    calcMarginTop() {
        const /** @type {?} */ firstNode = this.viewportNodes && this.viewportNodes.length && this.viewportNodes[0];
        // condition on root node is because the virtual root's self height is 0
        return firstNode
            ? Math.max(0, firstNode.position - firstNode.parent.position -
                (firstNode.parent.isRoot ? 0 : this.virtualScroll.averageNodeHeight))
            : 0;
    }
    /**
     * @param {?} nodes
     * @param {?} __1
     * @return {?}
     */
    getViewportNodes(nodes, { startPos, endPos }) {
        if (!nodes || !nodes.length) {
            return [];
        }
        // Search for first node in the viewport using binary search
        // Look for first node that starts after the beginning of the viewport (with buffer)
        // Or that ends after the beginning of the viewport
        const /** @type {?} */ firstIndex = binarySearch(nodes, (node) => {
            return startPos <= node.position || (startPos <= node.position + node.height);
        });
        // Search for last node in the viewport using binary search
        // Look for first node that starts after the end of the viewport (with buffer)
        const /** @type {?} */ lastIndex = binarySearch(nodes, (node) => {
            return endPos < node.position || (endPos <= node.position + node.height);
        }, firstIndex);
        const /** @type {?} */ viewportNodes = nodes.slice(firstIndex, lastIndex + 1);
        // console.log(this.node.id, 'first: ', firstIndex, 'last: ', lastIndex, viewportNodes)
        return viewportNodes;
    }
}
TreeNodeChildrenComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-tree-node-children',
                template: `<ngx-tree-node *ngFor="let child of viewportNodes; let i = index; trackBy: trackNode"
               [options]="options"
               [ngClass]="[options.nodeClass(child), 'tree-node-level-'+ child.level]"
               [class.tree-node-expanded]="child.isExpanded"
               [class.tree-node-collapsed]="child.isCollapsed"
               [class.tree-node-leaf]="child.isLeaf"
               [class.tree-node-active]="child.isActive"
               [class.tree-node-focused]="child.isFocused"
               [node]="child"
               [index]="i"
               [templates]="templates">
</ngx-tree-node>

<ngx-tree-loading *ngIf="!node.children"
                  [style.padding-left]="options.levelPadding(node)"
                  [template]="templates.loadingTemplate"
                  [node]="node"></ngx-tree-loading>
`,
                styles: [`:host{display:block;padding-left:20px}:host .tree-children-no-padding{padding-left:0}`],
                animations: [
                    trigger('expandAnimation', [
                        transition(':enter', [
                            style({ height: 0, overflow: 'hidden' }),
                            animate(EXPANSION_PANEL_ANIMATION_TIMING, style({ height: '*' })),
                        ]),
                        transition(':leave', [
                            style({ height: '*', overflow: 'hidden' }),
                            animate(EXPANSION_PANEL_ANIMATION_TIMING, style({ height: 0 })),
                        ]),
                    ]),
                ],
            },] },
];
/** @nocollapse */
TreeNodeChildrenComponent.ctorParameters = () => [
    { type: TreeVirtualScroll, },
];
TreeNodeChildrenComponent.propDecorators = {
    "options": [{ type: Input },],
    "node": [{ type: Input },],
    "templates": [{ type: Input },],
    "disableMarginTop": [{ type: Input },],
    "children": [{ type: Input },],
    "refreshTree": [{ type: Input },],
    "expandAnimation": [{ type: HostBinding, args: ['@expandAnimation',] },],
    "className": [{ type: HostBinding, args: ['class.tree-node-children',] },],
    "noPadding": [{ type: HostBinding, args: ['class.tree-children-no-padding',] },],
    "marginTopAttr": [{ type: HostBinding, args: ['style.margin-top.px',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TreeNodeContentComponent {
    constructor() {
        this.className = true;
    }
}
TreeNodeContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-tree-node-content',
                template: `<span *ngIf="!template">{{ node.displayField }}</span>

<ng-container
  [ngTemplateOutlet]="template"
  [ngTemplateOutletContext]="{ $implicit: null, node: node, index: index, options: options }">
</ng-container>
`,
                styles: [`:host{display:block;padding:2px 5px;border-radius:2px;-webkit-transition:background-color .15s,-webkit-box-shadow .15s;transition:background-color .15s,-webkit-box-shadow .15s;transition:background-color .15s,box-shadow .15s;transition:background-color .15s,box-shadow .15s,-webkit-box-shadow .15s;cursor:pointer;white-space:nowrap}`],
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
TreeNodeContentComponent.propDecorators = {
    "options": [{ type: Input },],
    "node": [{ type: Input },],
    "index": [{ type: Input },],
    "template": [{ type: Input },],
    "className": [{ type: HostBinding, args: ['class.tree-node-content',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TreeNodeDropSlotComponent {
    constructor() {
        this.allowDrop = (element, $event) => isFunction(this.options.allowDrop)
            ? this.options.allowDrop(element, {
                parent: this.node,
                index: this.dropIndex,
            }, $event)
            : false;
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDrop($event) {
        this.node.mouseAction('drop', $event.event, {
            from: $event.element,
            to: { parent: this.node, index: this.dropIndex },
        });
    }
}
TreeNodeDropSlotComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-tree-node-drop-slot',
                template: `<div class="tree-node-drop-slot"
     (ngxTreeDrop)="onDrop($event)"
     [treeAllowDrop]="allowDrop">
</div>
`,
                styles: [`:host{display:block;width:100%;z-index:1}:host.prev-drop-slot{top:0}:host.next-drop-slot{bottom:0}.tree-node-drop-slot{display:block;height:4px;background-color:#f08080}.tree-node-drop-slot.is-dragging-over{background:#dfe;outline:#888 dashed 2px}`],
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
TreeNodeDropSlotComponent.propDecorators = {
    "node": [{ type: Input },],
    "options": [{ type: Input },],
    "dropIndex": [{ type: Input },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TreeNodeExpanderComponent {
    constructor() {
        this.className = true;
    }
}
TreeNodeExpanderComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-tree-node-expander',
                template: `<ng-template [ngIf]="!template">
  <div *ngIf="node.hasChildren"
        class="toggle-children-wrapper"
        [class.toggle-children-expanded]="node.isExpanded"
        [class.toggle-children-collapsed]="node.isCollapsed"
        (click)="node.mouseAction('expanderClick', $event)">
    <span class="toggle-children"></span>
  </div>

  <div *ngIf="!node.hasChildren"
        class="toggle-children-placeholder"></div>
</ng-template>

<ng-container [ngTemplateOutlet]="template"
              [ngTemplateOutletContext]="{
                $implicit: null,
                node: node,
                index: index,
                options: options
              }">
</ng-container>
`,
                styles: [`:host{display:block;white-space:nowrap}.toggle-children-expanded .toggle-children{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.toggle-children-collapsed .toggle-children{-webkit-transform:rotate(0);transform:rotate(0)}.toggle-children-wrapper{padding:0 3px;cursor:pointer}.toggle-children{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAASCAYAAABSO15qAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABAhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjY1RTYzOTA2ODZDRjExREJBNkUyRDg4N0NFQUNCNDA3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkYzRkRFQjcxODUzNTExRTU4RTQwRkQwODFEOUZEMEE3IiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkYzRkRFQjcwODUzNTExRTU4RTQwRkQwODFEOUZEMEE3IiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6MTk5NzA1OGEtZDI3OC00NDZkLWE4ODgtNGM4MGQ4YWI1NzNmIiBzdFJlZjpkb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6YzRkZmQxMGMtY2NlNS0xMTc4LWE5OGQtY2NkZmM5ODk5YWYwIi8+IDxkYzp0aXRsZT4gPHJkZjpBbHQ+IDxyZGY6bGkgeG1sOmxhbmc9IngtZGVmYXVsdCI+Z2x5cGhpY29uczwvcmRmOmxpPiA8L3JkZjpBbHQ+IDwvZGM6dGl0bGU+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+5iogFwAAAGhJREFUeNpiYGBgKABigf///zOQg0EARH4A4gZyDIIZ8B/JoAJKDIDhB0CcQIkBRBtEyABkgxwoMQCGD6AbRKoBGAYxQgXIBRuZGKgAKPIC3QLxArnRSHZCIjspk52ZKMrOFBUoAAEGAKnq593MQAZtAAAAAElFTkSuQmCC);height:8px;width:9px;background-size:contain;display:inline-block;background-repeat:no-repeat;background-position:center}.toggle-children-placeholder{display:block;height:15px;width:15px}`],
            },] },
];
/** @nocollapse */
TreeNodeExpanderComponent.propDecorators = {
    "options": [{ type: Input },],
    "node": [{ type: Input },],
    "index": [{ type: Input },],
    "template": [{ type: Input },],
    "className": [{ type: HostBinding, args: ['class.tree-node-expander',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TreeNodeWrapperComponent {
    /**
     * @param {?} virtualScroll
     * @param {?} elementRef
     */
    constructor(virtualScroll, elementRef) {
        this.virtualScroll = virtualScroll;
        this.elementRef = elementRef;
        this.className = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.node.elementRef = this.elementRef;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.node.elementRef = null;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.virtualScroll.isDisabled() && !this.virtualScroll.hasEnoughNodeHeight) {
            this.virtualScroll.reportNodeHeight(this.elementRef.nativeElement.getBoundingClientRect().height);
        }
    }
}
TreeNodeWrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-tree-node-wrapper',
                template: `<ng-template [ngIf]="!templates.treeNodeWrapperTemplate">
  <ngx-tree-node-expander [node]="node"
                          [index]="index"
                          [options]="options"
                          [template]="templates.expanderTemplate"></ngx-tree-node-expander>

  <ngx-tree-node-content [node]="node"
                         [index]="index"
                         [options]="options"
                         [template]="templates.treeNodeTemplate">
  </ngx-tree-node-content>
</ng-template>

<ng-container [ngTemplateOutlet]="templates.treeNodeWrapperTemplate"
              [ngTemplateOutletContext]="{
                $implicit: null,
                node: node,
                index: index,
                options: options,
                templates: templates
              }">
</ng-container>
`,
                styles: [`:host{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}:host ::ng-deep .tree-node-content:hover{background-color:#f7fbff}:host(.ngx-tree-dragging-target) ::ng-deep .tree-node-expander{visibility:hidden}:host(.tree-node-wrapper-active) ::ng-deep .tree-node-content,:host(.tree-node-wrapper-active) ::ng-deep .tree-node-content:hover,:host(.tree-node-wrapper-active).tree-node-wrapper-focused ::ng-deep .tree-node-content{background-color:#beebff}:host(.tree-node-wrapper-focused) ::ng-deep .tree-node-content{background-color:#e7f4f9}:host ::ng-deep .tree-node-content:hover,:host(.tree-node-wrapper-active) ::ng-deep .tree-node-content,:host(.tree-node-wrapper-focused) ::ng-deep .tree-node-content{-webkit-box-shadow:inset 0 0 1px #999;box-shadow:inset 0 0 1px #999}:host(.is-dragging-over) .tree-node-content{position:relative;z-index:1;background-color:#dfe;-webkit-box-shadow:inset 0 0 1px #999;box-shadow:inset 0 0 1px #999;outline:#888 dashed 2px}:host(.is-dragging-over) .tree-node-content *,:host(.is-dragging-over) .tree-node-expander *{pointer-events:none}:host(.is-dragging-over-disabled) .tree-node-content{opacity:.5}`],
            },] },
];
/** @nocollapse */
TreeNodeWrapperComponent.ctorParameters = () => [
    { type: TreeVirtualScroll, },
    { type: ElementRef, },
];
TreeNodeWrapperComponent.propDecorators = {
    "node": [{ type: Input },],
    "options": [{ type: Input },],
    "index": [{ type: Input },],
    "templates": [{ type: Input },],
    "className": [{ type: HostBinding, args: ['class.tree-node-wrapper',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TreeNodeComponent {
    constructor() {
        this.className = true;
    }
    /**
     * @return {?}
     */
    get allowDrop() {
        return (node, $event) => {
            return isFunction(this.options.allowDrop)
                ? this.options.allowDrop(node, { parent: this.node, index: node.index }, $event)
                : this.options.allowDrop;
        };
    }
    /**
     * @param {?} node
     * @return {?}
     */
    allowDrag(node) {
        return isFunction(this.options.allowDrag) ? this.options.allowDrag(node) : this.options.allowDrag;
    }
}
TreeNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-tree-node',
                template: `<ng-template [ngIf]="!templates.treeNodeFullTemplate">
  <ngx-tree-node-wrapper [style.padding-left]="options.levelPadding(node)"
                         [node]="node"
                         [options]="options"
                         [index]="index"
                         [templates]="templates"
                         [class.tree-node-wrapper-active]="node.isActive"
                         [class.tree-node-wrapper-focused]="node.isFocused"
                         (click)="node.mouseAction('click', $event)"
                         (dblclick)="node.mouseAction('dblClick', $event)"
                         (contextmenu)="node.mouseAction('contextMenu', $event)"
                         (ngxTreeDrop)="node.onDrop($event)"
                         (treeDropDragOver)="node.mouseAction('dragOver', $event)"
                         (treeDropDragLeave)="node.mouseAction('dragLeave', $event)"
                         (treeDropDragEnter)="node.mouseAction('dragEnter', $event)"
                         [treeAllowDrop]="allowDrop"
                         [ngxTreeDrag]="node"
                         [treeDragEnabled]="allowDrag(node)">
  </ngx-tree-node-wrapper>

  <ngx-tree-node-children *ngIf="node.isExpanded && node.hasVisibleChildren"
                          [node]="node"
                          [options]="options"
                          [children]="node.visibleChildren"
                          [templates]="templates"></ngx-tree-node-children>
</ng-template>

<ng-container
  [ngTemplateOutlet]="templates.treeNodeFullTemplate"
  [ngTemplateOutletContext]="{ $implicit: null, node: node, index: index, options: options, templates: templates }">
</ng-container>
`,
                styles: [`:host{display:block;position:relative}`],
            },] },
];
/** @nocollapse */
TreeNodeComponent.propDecorators = {
    "node": [{ type: Input },],
    "options": [{ type: Input },],
    "index": [{ type: Input },],
    "templates": [{ type: Input },],
    "className": [{ type: HostBinding, args: ['class.tree-node',] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DISABLE_ON_SCROLL_CLASS = 'disable-events-on-scroll';
class TreeViewportComponent {
    /**
     * @param {?} virtualScroll
     * @param {?} elementRef
     * @param {?} renderer
     */
    constructor(virtualScroll, elementRef, renderer) {
        this.virtualScroll = virtualScroll;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.lastScrollTop = 0;
        this.isScrolling = false;
        this.className = true;
        this.ticking = false;
        this.scrollIntoViewTicking = false;
        this.structureChangeSub = Subscription.EMPTY;
        this.scrollIntoViewSub = Subscription.EMPTY;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onScroll(event) {
        this.disableEventsWhenScrolling();
        if (this.virtualScroll.isDisabled()) {
            return;
        }
        const /** @type {?} */ currentScrollTop = this.elementRef.nativeElement.scrollTop;
        if (Math.abs(currentScrollTop - this.lastScrollTop) < this.virtualScroll.averageNodeHeight) {
            return false;
        }
        this.lastScrollTop = currentScrollTop;
        if (!this.ticking) {
            window.requestAnimationFrame(() => {
                this.setViewport();
                this.ticking = false;
            });
            this.ticking = true;
        }
        event.preventDefault();
        event.stopPropagation();
        return false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.scrollIntoViewSub = this.treeModel.scrollIntoView$.subscribe((target) => {
            if (target.node.elementRef) {
                this.scrollIntoViewAndTick(target, () => {
                    const /** @type {?} */ lastTarget = this.lastScrollIntoViewTarget;
                    if (lastTarget.node.elementRef.nativeElement.scrollIntoViewIfNeeded) {
                        lastTarget.node.elementRef.nativeElement.scrollIntoViewIfNeeded(lastTarget.scrollToMiddle);
                    }
                    else {
                        lastTarget.node.elementRef.nativeElement.scrollIntoView({
                            behavior: 'auto',
                            block: 'end',
                        });
                    }
                });
            }
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('treeModel' in changes) {
            this.virtualScroll.setDisabled(!this.enable);
            if (this.virtualScroll.isDisabled()) {
                if (!changes["treeModel"].isFirstChange()) {
                    this.treeModel.fireEvent({ eventName: TREE_EVENTS.initialized });
                }
                return;
            }
            this.initEventSubscription();
            this.virtualScroll.reCalcPositions(this.treeModel);
            if (!changes["treeModel"].isFirstChange()) {
                // use setTimeout to avoid do calculation on old data,
                // let the new data render first round
                setTimeout(() => {
                    this.setViewport();
                    this.treeModel.fireEvent({ eventName: TREE_EVENTS.initialized });
                });
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout(() => {
            if (this.virtualScroll.isDisabled()) {
                this.treeModel.fireEvent({ eventName: TREE_EVENTS.initialized });
                return;
            }
            this.virtualScroll.reCalcPositions(this.treeModel);
            this.setViewport();
            this.treeModel.fireEvent({ eventName: TREE_EVENTS.initialized });
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.structureChangeSub) {
            this.structureChangeSub.unsubscribe();
        }
        if (this.scrollIntoViewSub) {
            this.scrollIntoViewSub.unsubscribe();
        }
    }
    /**
     * @param {?} target
     * @param {?} scrollCallback
     * @return {?}
     */
    scrollIntoViewAndTick(target, scrollCallback) {
        this.lastScrollIntoViewTarget = target;
        if (!this.scrollIntoViewTicking) {
            window.requestAnimationFrame(() => {
                scrollCallback();
                this.scrollIntoViewTicking = false;
            });
            this.scrollIntoViewTicking = true;
        }
    }
    /**
     * @return {?}
     */
    initEventSubscription() {
        this.ngOnDestroy();
        this.scrollIntoViewSub = this.treeModel.scrollIntoView$.subscribe((target) => {
            this.scrollIntoViewAndTick(target, () => {
                const /** @type {?} */ lastTarget = this.lastScrollIntoViewTarget;
                const /** @type {?} */ targetOffset = this.virtualScroll.scrollIntoView(lastTarget.node, lastTarget.force, lastTarget.scrollToMiddle);
                if (targetOffset) {
                    this.elementRef.nativeElement.scrollTop = targetOffset;
                }
            });
        });
        this.structureChangeSub = merge(this.treeModel.events.expand, this.treeModel.events.collapse, this.treeModel.events.loadChildren, this.treeModel.events.changeFilter, this.treeModel.events.addNode, this.treeModel.events.removeNode)
            .subscribe(() => {
            this.virtualScroll.reCalcPositions(this.treeModel);
            this.setViewport();
        });
    }
    /**
     * @return {?}
     */
    setViewport() {
        if (this.virtualScroll.isDisabled()) {
            return;
        }
        this.virtualScroll.adjustViewport(this.elementRef.nativeElement.getBoundingClientRect(), this.lastScrollTop);
    }
    /**
     * @return {?}
     */
    disableEventsWhenScrolling() {
        if (this.scrollTimer) {
            clearTimeout(this.scrollTimer);
        }
        else {
            this.isScrolling = true;
            this.renderer.addClass(this.elementRef.nativeElement, DISABLE_ON_SCROLL_CLASS);
        }
        this.scrollTimer = /** @type {?} */ (setTimeout(() => {
            this.isScrolling = false;
            this.renderer.removeClass(this.elementRef.nativeElement, DISABLE_ON_SCROLL_CLASS);
            this.scrollTimer = null;
        }, 120));
    }
}
TreeViewportComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-tree-viewport',
                template: `<ng-content></ng-content>
`,
                styles: [`:host{height:100%;overflow:auto;display:block}`],
                providers: [TreeVirtualScroll],
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
TreeViewportComponent.ctorParameters = () => [
    { type: TreeVirtualScroll, },
    { type: ElementRef, },
    { type: Renderer2, },
];
TreeViewportComponent.propDecorators = {
    "enable": [{ type: Input },],
    "treeModel": [{ type: Input },],
    "className": [{ type: HostBinding, args: ['class.tree-viewport',] },],
    "onScroll": [{ type: HostListener, args: ['scroll', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TreeDraggingTargetService extends Subject {
    constructor() {
        super(...arguments);
        this._draggedElement = null;
    }
    /**
     * @param {?} draggedElement
     * @return {?}
     */
    set(draggedElement) {
        this._draggedElement = draggedElement;
    }
    /**
     * @return {?}
     */
    get() {
        return this._draggedElement;
    }
    /**
     * @return {?}
     */
    isDragging() {
        return !!this.get();
    }
}
TreeDraggingTargetService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class TreeComponent {
    /**
     * @param {?} treeDraggingTargetService
     */
    constructor(treeDraggingTargetService) {
        this.treeDraggingTargetService = treeDraggingTargetService;
        this.treeModel = null;
        this.refreshTree = false;
        this.enableAnimation = true;
        this.keepNodesExpanded = false;
        this.expand = null;
        this.collapse = null;
        this.toggleExpander = null;
        this.activate = null;
        this.deactivate = null;
        this.focus = null;
        this.blur = null;
        this.initialized = null;
        this.moveNode = null;
        this.loadChildren = null;
        this.changeFilter = null;
        this.addNode = null;
        this.removeNode = null;
        this.className = true;
        this.emitterMap = /** @type {?} */ (Object.keys(TREE_EVENTS).reduce((map, name) => {
            if (!this.hasOwnProperty(name)) {
                throw new TypeError(`Unmatched events: [${name}]`);
            }
            this[name] = map[name] = new EventEmitter();
            return map;
        }, {}));
        this.UIOptions = createTreeUIOptions();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["nodes"] && changes["nodes"].currentValue) {
            const /** @type {?} */ oldTreeModel = this.treeModel;
            this.treeModel = new TreeModel(changes["nodes"].currentValue, this.emitterMap, this.dataOptions);
            if (oldTreeModel && this.keepNodesExpanded) {
                oldTreeModel.expandedNodes.forEach(node => {
                    this.treeModel.setExpandedNodeInPlace(node);
                });
            }
            if (!changes["nodes"].isFirstChange()) {
                this.refreshTree = true;
            }
        }
        else if (changes["dataOptions"] && changes["dataOptions"].currentValue && this.treeModel) {
            this.treeModel.updateOptions(changes["dataOptions"].currentValue);
        }
        if (changes["focusTarget"] && changes["focusTarget"].currentValue && this.treeModel) {
            this.treeModel.focusNode(this.focusTarget);
        }
        if (changes["activateTarget"] && changes["activateTarget"].currentValue && this.treeModel) {
            this.treeModel.activateNode(this.activateTarget);
        }
        if (changes["allowDrag"] || changes["allowDrop"]
            || changes["levelPadding"]
            || changes["useVirtualScroll"]
            || changes["nodeClass"]) {
            this.UIOptions = createTreeUIOptions({
                allowDrag: this.allowDrag,
                allowDrop: this.allowDrop,
                levelPadding: this.levelPadding,
                useVirtualScroll: this.useVirtualScroll,
                nodeClass: this.nodeClass,
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        each(this.emitterMap, function (emitter) {
            emitter.complete();
        });
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onKeydown($event) {
        if (!this.treeModel.isFocused) {
            return;
        }
        if (['input', 'textarea'].includes(document.activeElement.tagName.toLowerCase())) {
            return;
        }
        const /** @type {?} */ focusedNode = this.treeModel.focusedNode;
        this.treeModel.performKeyAction(focusedNode, $event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onMousedown($event) {
        const /** @type {?} */ insideClick = $event.target.closest('ngx-tree');
        if (!insideClick) {
            this.treeModel.setFocus(false);
        }
    }
    /**
     * @return {?}
     */
    sizeChanged() {
        this.viewportComponent.setViewport();
    }
}
TreeComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-tree',
                template: `<ngx-tree-viewport [@.disabled]="!enableAnimation || viewport.isScrolling"
                   [enable]="useVirtualScroll"
                   [treeModel]="treeModel"
                   #viewport>
  <div *ngIf="!viewport.virtualScroll.isDisabled()"
       class="height-raiser"
       [style.height.px]="treeModel?.virtualRoot.height"></div>
  <div class="tree-root"
       [class.node-dragging]="treeDraggingTargetService.isDragging()"
       [class.virtual-scroll-disabled]="viewport.virtualScroll.isDisabled()"
       [style.transform]="'translateY(' + root.marginTop + 'px)'">
    <ngx-tree-node-children #root
                            [options]="UIOptions"
                            [disableMarginTop]="true"
                            [node]="treeModel?.virtualRoot"
                            [children]="treeModel?.roots"
                            [refreshTree]="refreshTree"
                            [templates]="{
                              expanderTemplate: expanderTemplate,
                              loadingTemplate: loadingTemplate,
                              treeNodeTemplate: treeNodeTemplate,
                              treeNodeWrapperTemplate: treeNodeWrapperTemplate,
                              treeNodeFullTemplate: treeNodeFullTemplate
                            }">
    </ngx-tree-node-children>
  </div>
</ngx-tree-viewport>
`,
                styles: [`:host{display:block}ngx-tree-viewport{position:relative}ngx-tree-viewport.disable-events-on-scroll .tree-root /deep/ *{pointer-events:none}.tree-children{padding-left:20px}.height-raiser{-webkit-transition:height 250ms ease-in;transition:height 250ms ease-in}.tree-root{top:0;width:100%;height:100%;position:absolute;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.tree-root.virtual-scroll-disabled{position:static}/deep/ .ngx-tree-dragging-target *{pointer-events:none}`],
            },] },
];
/** @nocollapse */
TreeComponent.ctorParameters = () => [
    { type: TreeDraggingTargetService, },
];
TreeComponent.propDecorators = {
    "nodes": [{ type: Input },],
    "focusTarget": [{ type: Input },],
    "activateTarget": [{ type: Input },],
    "dataOptions": [{ type: Input },],
    "allowDrag": [{ type: Input },],
    "allowDrop": [{ type: Input },],
    "levelPadding": [{ type: Input },],
    "useVirtualScroll": [{ type: Input },],
    "nodeClass": [{ type: Input },],
    "enableAnimation": [{ type: Input },],
    "keepNodesExpanded": [{ type: Input },],
    "expand": [{ type: Output },],
    "collapse": [{ type: Output },],
    "toggleExpander": [{ type: Output },],
    "activate": [{ type: Output },],
    "deactivate": [{ type: Output },],
    "focus": [{ type: Output },],
    "blur": [{ type: Output },],
    "initialized": [{ type: Output },],
    "moveNode": [{ type: Output },],
    "loadChildren": [{ type: Output },],
    "changeFilter": [{ type: Output },],
    "addNode": [{ type: Output },],
    "removeNode": [{ type: Output },],
    "className": [{ type: HostBinding, args: ['class.ngx-tree',] },],
    "loadingTemplate": [{ type: ContentChild, args: ['loadingTemplate',] },],
    "expanderTemplate": [{ type: ContentChild, args: ['expanderTemplate',] },],
    "treeNodeTemplate": [{ type: ContentChild, args: ['treeNodeTemplate',] },],
    "treeNodeWrapperTemplate": [{ type: ContentChild, args: ['treeNodeWrapperTemplate',] },],
    "treeNodeFullTemplate": [{ type: ContentChild, args: ['treeNodeFullTemplate',] },],
    "viewportComponent": [{ type: ViewChild, args: ['viewport',] },],
    "root": [{ type: ViewChild, args: ['root',] },],
    "onKeydown": [{ type: HostListener, args: ['body: keydown', ['$event'],] },],
    "onMousedown": [{ type: HostListener, args: ['body: mousedown', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DRAGGING_TARGET_CLASS = 'ngx-tree-dragging-target';
class TreeDragDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} treeDraggingTargetService
     */
    constructor(el, renderer, treeDraggingTargetService) {
        this.el = el;
        this.renderer = renderer;
        this.treeDraggingTargetService = treeDraggingTargetService;
    }
    /**
     * @param {?} ev
     * @return {?}
     */
    onDragStart(ev) {
        // setting the data is required by firefox
        ev.dataTransfer.setData('text', this.draggingTarget.id);
        ev.dataTransfer.dropEffect = 'move';
        this.renderer.addClass(this.el.nativeElement, DRAGGING_TARGET_CLASS);
        this.treeDraggingTargetService.set(this.draggingTarget);
        if (this.draggingTarget.mouseAction) {
            this.draggingTarget.mouseAction('dragStart', ev);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragEnd(event) {
        if (this.draggingTarget.mouseAction) {
            this.draggingTarget.mouseAction('dragEnd', event);
        }
        this.renderer.removeClass(this.el.nativeElement, DRAGGING_TARGET_CLASS);
        this.treeDraggingTargetService.set(null);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('treeDragEnabled' in changes) {
            this.renderer.setAttribute(this.el.nativeElement, 'draggable', this.treeDragEnabled ? 'true' : 'false');
        }
    }
}
TreeDragDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngxTreeDrag]',
            },] },
];
/** @nocollapse */
TreeDragDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: TreeDraggingTargetService, },
];
TreeDragDirective.propDecorators = {
    "draggingTarget": [{ type: Input, args: ['ngxTreeDrag',] },],
    "treeDragEnabled": [{ type: Input },],
    "onDragStart": [{ type: HostListener, args: ['dragstart', ['$event'],] },],
    "onDragEnd": [{ type: HostListener, args: ['dragend', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const DRAG_OVER_CLASS = 'is-dragging-over';
const DRAG_DISABLED_CLASS = 'is-dragging-over-disabled';
class TreeDropDirective {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} treeDraggedElement
     */
    constructor(el, renderer, treeDraggedElement) {
        this.el = el;
        this.renderer = renderer;
        this.treeDraggedElement = treeDraggedElement;
        this.onDrop$ = new EventEmitter();
        this.onDragOver$ = new EventEmitter();
        this.onDragLeave$ = new EventEmitter();
        this.onDragEnter$ = new EventEmitter();
        this._allowDrop = (element, $event) => true;
    }
    /**
     * @param {?} allowDrop
     * @return {?}
     */
    set treeAllowDrop(allowDrop) {
        this._allowDrop = isFunction(allowDrop) ? allowDrop : (element, $event) => allowDrop;
    }
    /**
     * @return {?}
     */
    get treeAllowDrop() {
        return this._allowDrop;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.onDrop$.complete();
        this.onDragEnter$.complete();
        this.onDragLeave$.complete();
        this.onDragOver$.complete();
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDragOver($event) {
        if (!this.allowDrop($event)) {
            return;
        }
        this.onDragOver$.emit({ event: $event, element: this.treeDraggedElement.get() });
        if (!this.dragOverClassAdded) {
            this.addClass();
        }
        this._stopEvent(event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDragEnter($event) {
        if (!this.allowDrop($event)) {
            this.addDisabledClass();
            return;
        }
        this.addClass();
        this.onDragEnter$.emit({ event: $event, element: this.treeDraggedElement.get() });
        this._stopEvent(event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDragLeave($event) {
        if (!this.allowDrop($event)) {
            this.removeDisabledClass();
            return;
        }
        this.removeClass();
        this.onDragLeave$.emit({ event: $event, element: this.treeDraggedElement.get() });
        this._stopEvent(event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onDrop($event) {
        if (!this.allowDrop($event)) {
            return;
        }
        this.removeClass();
        this.onDrop$.emit({ event: $event, element: this.treeDraggedElement.get() });
        this.treeDraggedElement.set(null);
        this._stopEvent($event);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    allowDrop($event) {
        return this._allowDrop(this.treeDraggedElement.get(), $event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _stopEvent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * @return {?}
     */
    addClass() {
        this.dragOverClassAdded = true;
        this.renderer.addClass(this.el.nativeElement, DRAG_OVER_CLASS);
    }
    /**
     * @return {?}
     */
    removeClass() {
        this.dragOverClassAdded = false;
        this.renderer.removeClass(this.el.nativeElement, DRAG_OVER_CLASS);
    }
    /**
     * @return {?}
     */
    addDisabledClass() {
        this.disabledClassAdded = true;
        this.renderer.addClass(this.el.nativeElement, DRAG_DISABLED_CLASS);
    }
    /**
     * @return {?}
     */
    removeDisabledClass() {
        this.disabledClassAdded = false;
        this.renderer.removeClass(this.el.nativeElement, DRAG_DISABLED_CLASS);
    }
}
TreeDropDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngxTreeDrop]',
            },] },
];
/** @nocollapse */
TreeDropDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
    { type: TreeDraggingTargetService, },
];
TreeDropDirective.propDecorators = {
    "onDrop$": [{ type: Output, args: ['ngxTreeDrop',] },],
    "onDragOver$": [{ type: Output, args: ['treeDropDragOver',] },],
    "onDragLeave$": [{ type: Output, args: ['treeDropDragLeave',] },],
    "onDragEnter$": [{ type: Output, args: ['treeDropDragEnter',] },],
    "treeAllowDrop": [{ type: Input },],
    "onDragOver": [{ type: HostListener, args: ['dragover', ['$event'],] },],
    "onDragEnter": [{ type: HostListener, args: ['dragenter', ['$event'],] },],
    "onDragLeave": [{ type: HostListener, args: ['dragleave', ['$event'],] },],
    "onDrop": [{ type: HostListener, args: ['drop', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxTreeModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgxTreeModule,
            providers: [
                TreeDraggingTargetService,
                {
                    provide: VIRTUAL_SCROLL_NODE_HEIGHT_QUOTA,
                    useValue: 5,
                },
            ],
        };
    }
}
NgxTreeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [
                    TreeLoadingComponent,
                    TreeNodeComponent,
                    TreeComponent,
                    TreeNodeExpanderComponent,
                    TreeNodeWrapperComponent,
                    TreeNodeChildrenComponent,
                    TreeNodeContentComponent,
                    TreeViewportComponent,
                    TreeNodeDropSlotComponent,
                    TreeDragDirective,
                    TreeDropDirective,
                ],
                exports: [
                    TreeLoadingComponent,
                    TreeNodeComponent,
                    TreeComponent,
                    TreeNodeExpanderComponent,
                    TreeNodeWrapperComponent,
                    TreeNodeChildrenComponent,
                    TreeNodeContentComponent,
                    TreeViewportComponent,
                    TreeNodeDropSlotComponent,
                    TreeDragDirective,
                    TreeDropDirective,
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Public API Surface of ngx-tree
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { NgxTreeModule, TreeLoadingComponent, TreeNodeChildrenComponent, TreeNodeContentComponent, TreeNodeDropSlotComponent, TreeNodeExpanderComponent, TreeNodeWrapperComponent, TreeNodeComponent, TreeViewportComponent, TreeComponent, TreeDragDirective, TreeDropDirective, TreeDraggingTargetService, TreeVirtualScroll, VIRTUAL_SCROLL_NODE_HEIGHT_QUOTA, defaultUIOptions, defaultDataOptions, createTreeUIOptions, createTreeDataOptions, TreeModel, TreeNode, TREE_ACTIONS, defaultActionMapping, TREE_EVENTS, NUMBER_KEYS, STRING_KEYS };
//# sourceMappingURL=e-cloud-ngx-tree.js.map
