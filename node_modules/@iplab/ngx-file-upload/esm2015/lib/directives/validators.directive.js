/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, forwardRef, Input } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { FileUploadValidators } from './../helpers/validators.class';
import { IsNullOrEmpty } from './../helpers/helpers.class';
import { FileUploadService } from './../services/file-upload.service';
/**
 * A Directive that adds the `filesize` validator to controls marked with the
 * `filesize` attribute. The size of the file is in bytes or any other unit
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel filesize="830000"></file-upload>
 * <file-upload name="files" ngModel [filesize]="830000"></file-upload>
 * <file-upload name="files" ngModel minSize="0" max="6200"></file-upload>
 * <file-upload name="files" ngModel filesize="123MB"></file-upload>
 * <file-upload name="files" ngModel [filesize]="12 mb"></file-upload>
 * <file-upload name="files" ngModel minSize="0" max="324KB"></file-upload>
 * ```
 *
 */
export class FileSizeValidator {
    /**
     * @param {?} fileUploadService
     */
    constructor(fileUploadService) {
        this.fileUploadService = fileUploadService;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('filesize' in changes
            || 'maxsize' in changes
            || 'minsize' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.validator(c);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    /**
     * @private
     * @return {?}
     */
    _createValidator() {
        /** @type {?} */
        let maxSize = null;
        if (!IsNullOrEmpty(this.maxsize)) {
            maxSize = this.fileUploadService.parseSize(this.maxsize);
        }
        else if (!IsNullOrEmpty(this.filesize)) {
            maxSize = this.fileUploadService.parseSize(this.filesize);
        }
        /** @type {?} */
        const minSize = this.fileUploadService.parseSize(this.minsize);
        this.validator = FileUploadValidators.sizeRange({ maxSize, minSize });
    }
}
FileSizeValidator.decorators = [
    { type: Directive, args: [{
                selector: `file-upload[filesize][formControlName],
    file-upload[filesize][formControl],
    file-upload[filesize][ngModel],
    file-upload[minsize][formControlName],
    file-upload[minsize][formControl],
    file-upload[minsize][ngModel],
    file-upload[maxsize][formControlName],
    file-upload[maxsize][formControl],
    file-upload[maxsize][ngModel]`,
                providers: [{
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FileSizeValidator)),
                        multi: true
                    }],
                host: {
                    '[attr.filesize]': 'filesize ? filesize : null',
                    '[attr.minsize]': 'minsize ? minsize : null',
                    '[attr.maxsize]': 'maxsize ? maxsize : null'
                }
            },] }
];
/** @nocollapse */
FileSizeValidator.ctorParameters = () => [
    { type: FileUploadService }
];
FileSizeValidator.propDecorators = {
    filesize: [{ type: Input }],
    minsize: [{ type: Input }],
    maxsize: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FileSizeValidator.prototype.filesize;
    /** @type {?} */
    FileSizeValidator.prototype.minsize;
    /** @type {?} */
    FileSizeValidator.prototype.maxsize;
    /**
     * @type {?}
     * @private
     */
    FileSizeValidator.prototype.validator;
    /**
     * @type {?}
     * @private
     */
    FileSizeValidator.prototype.onChange;
    /**
     * @type {?}
     * @private
     */
    FileSizeValidator.prototype.fileUploadService;
}
/**
 * A Directive that adds the `fileslimit` validator to controls marked with the
 * `fileslimit` attribute.
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel fileslimit="2"></file-upload>
 * <file-upload name="files" ngModel [fileslimit]="2"></file-upload>
 * ```
 *
 */
export class FilesLimitValidator {
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('fileslimit' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.fileslimit != null ? this.validator(c) : null;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    /**
     * @private
     * @return {?}
     */
    _createValidator() {
        this.validator = FileUploadValidators.filesLimit(typeof this.fileslimit === 'string' ? parseInt(this.fileslimit, 10) : this.fileslimit);
    }
}
FilesLimitValidator.decorators = [
    { type: Directive, args: [{
                selector: 'file-upload[fileslimit][formControlName], file-upload[fileslimit][formControl], file-upload[fileslimit][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FilesLimitValidator)),
                        multi: true
                    }],
                host: { '[attr.fileslimit]': 'fileslimit ? fileslimit : null' }
            },] }
];
FilesLimitValidator.propDecorators = {
    fileslimit: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FilesLimitValidator.prototype.fileslimit;
    /**
     * @type {?}
     * @private
     */
    FilesLimitValidator.prototype.validator;
    /**
     * @type {?}
     * @private
     */
    FilesLimitValidator.prototype.onChange;
}
/**
 * A Directive that adds the `accept` validator to controls marked with the
 * `accept` attribute.
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel accept="file_extension|audio/*|video/*|image/*|media_type"></file-upload>
 * <file-upload name="files" ngModel [accept]="file_extension|audio/*|video/*|image/*|media_type"></file-upload>
 * ```
 *
 * To specify more than one value, separate the values with a comma (e.g. <file-upload accept="audio/*,video/*,image/*"></file-upload>.
 *
 */
export class FilesAcceptValidator {
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('accept' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.accept != null ? this.validator(c) : null;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    /**
     * @private
     * @return {?}
     */
    _createValidator() {
        this.validator = FileUploadValidators.accept(this.accept.split(','));
    }
}
FilesAcceptValidator.decorators = [
    { type: Directive, args: [{
                selector: 'file-upload[accept][formControlName], file-upload[accept][formControl], file-upload[accept][ngModel]',
                providers: [{
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FilesAcceptValidator)),
                        multi: true
                    }],
                host: { '[attr.accept]': 'accept ? accept : null' }
            },] }
];
FilesAcceptValidator.propDecorators = {
    accept: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FilesAcceptValidator.prototype.accept;
    /**
     * @type {?}
     * @private
     */
    FilesAcceptValidator.prototype.validator;
    /**
     * @type {?}
     * @private
     */
    FilesAcceptValidator.prototype.onChange;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9ycy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AaXBsYWIvbmd4LWZpbGUtdXBsb2FkLyIsInNvdXJjZXMiOlsibGliL2RpcmVjdGl2ZXMvdmFsaWRhdG9ycy5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBK0QsTUFBTSxlQUFlLENBQUM7QUFDMUgsT0FBTyxFQUFFLGFBQWEsRUFBOEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzRSxPQUFPLEVBQWlDLG9CQUFvQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDcEcsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzNELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQXdDdEUsTUFBTSxPQUFPLGlCQUFpQjs7OztJQWExQixZQUE2QixpQkFBb0M7UUFBcEMsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtJQUFFLENBQUM7Ozs7O0lBSTdELFdBQVcsQ0FBQyxPQUFzQjtRQUNyQyxJQUFJLFVBQVUsSUFBSSxPQUFPO2VBQ2xCLFNBQVMsSUFBSSxPQUFPO2VBQ3BCLFNBQVMsSUFBSSxPQUFPLEVBQUU7WUFDM0IsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDeEIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNmLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQzthQUNuQjtTQUNGO0lBQ0wsQ0FBQzs7Ozs7SUFFTSxRQUFRLENBQUMsQ0FBa0I7UUFDOUIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdCLENBQUM7Ozs7O0lBRU0seUJBQXlCLENBQUMsRUFBYztRQUMzQyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUN2QixDQUFDOzs7OztJQUVPLGdCQUFnQjs7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Ozs7QUErQ2pDLE1BQU0sT0FBTyxvQkFBb0I7Ozs7O0lBU3RCLFdBQVcsQ0FBQyxPQUFzQjtRQUNyQyxJQUFJLFFBQVEsSUFBSSxPQUFPLEVBQUU7WUFDdkIsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDeEIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO2dCQUNmLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQzthQUNuQjtTQUNGO0lBQ0wsQ0FBQzs7Ozs7SUFFTSxRQUFRLENBQUMsQ0FBa0I7UUFDOUIsT0FBTyxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0lBQzFELENBQUM7Ozs7O0lBRU0seUJBQXlCLENBQUMsRUFBYztRQUMzQyxJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQztJQUN2QixDQUFDOzs7OztJQUVPLGdCQUFnQjtRQUNwQixJQUFJLENBQUMsU0FBUyxHQUFHLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7OztZQXJDSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLHNHQUFzRztnQkFDaEgsU0FBUyxFQUFFLENBQUM7d0JBQ1IsT0FBTyxFQUFFLGFBQWE7d0JBQ3RCLFdBQVcsRUFBRSxVQUFVOzs7d0JBQUMsR0FBRyxFQUFFLENBQUMsb0JBQW9CLEVBQUM7d0JBQ25ELEtBQUssRUFBRSxJQUFJO3FCQUNkLENBQUM7Z0JBQ0YsSUFBSSxFQUFFLEVBQUMsZUFBZSxFQUFFLHdCQUF3QixFQUFDO2FBQ3BEOzs7cUJBR0ksS0FBSzs7OztJQUFOLHNDQUNzQjs7Ozs7SUFFdEIseUNBQStCOzs7OztJQUUvQix3Q0FBNkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIGZvcndhcmRSZWYsIElucHV0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMsIEhvc3QsIFNlbGYsIE9wdGlvbmFsLCBIb3N0QmluZGluZyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIEZpbGVVcGxvYWRWYWxpZGF0b3JzIH0gZnJvbSAnLi8uLi9oZWxwZXJzL3ZhbGlkYXRvcnMuY2xhc3MnO1xyXG5pbXBvcnQgeyBJc051bGxPckVtcHR5IH0gZnJvbSAnLi8uLi9oZWxwZXJzL2hlbHBlcnMuY2xhc3MnO1xyXG5pbXBvcnQgeyBGaWxlVXBsb2FkU2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvZmlsZS11cGxvYWQuc2VydmljZSc7XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYGZpbGVzaXplYCB2YWxpZGF0b3IgdG8gY29udHJvbHMgbWFya2VkIHdpdGggdGhlXHJcbiAqIGBmaWxlc2l6ZWAgYXR0cmlidXRlLiBUaGUgc2l6ZSBvZiB0aGUgZmlsZSBpcyBpbiBieXRlcyBvciBhbnkgb3RoZXIgdW5pdFxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgZmlsZXNpemU9XCI4MzAwMDBcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBbZmlsZXNpemVdPVwiODMwMDAwXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgbWluU2l6ZT1cIjBcIiBtYXg9XCI2MjAwXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgZmlsZXNpemU9XCIxMjNNQlwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIFtmaWxlc2l6ZV09XCIxMiBtYlwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIG1pblNpemU9XCIwXCIgbWF4PVwiMzI0S0JcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiBgYGBcclxuICpcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6IGBmaWxlLXVwbG9hZFtmaWxlc2l6ZV1bZm9ybUNvbnRyb2xOYW1lXSxcclxuICAgIGZpbGUtdXBsb2FkW2ZpbGVzaXplXVtmb3JtQ29udHJvbF0sXHJcbiAgICBmaWxlLXVwbG9hZFtmaWxlc2l6ZV1bbmdNb2RlbF0sXHJcbiAgICBmaWxlLXVwbG9hZFttaW5zaXplXVtmb3JtQ29udHJvbE5hbWVdLFxyXG4gICAgZmlsZS11cGxvYWRbbWluc2l6ZV1bZm9ybUNvbnRyb2xdLFxyXG4gICAgZmlsZS11cGxvYWRbbWluc2l6ZV1bbmdNb2RlbF0sXHJcbiAgICBmaWxlLXVwbG9hZFttYXhzaXplXVtmb3JtQ29udHJvbE5hbWVdLFxyXG4gICAgZmlsZS11cGxvYWRbbWF4c2l6ZV1bZm9ybUNvbnRyb2xdLFxyXG4gICAgZmlsZS11cGxvYWRbbWF4c2l6ZV1bbmdNb2RlbF1gLFxyXG4gICAgcHJvdmlkZXJzOiBbe1xyXG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXHJcbiAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRmlsZVNpemVWYWxpZGF0b3IpLFxyXG4gICAgICAgIG11bHRpOiB0cnVlXHJcbiAgICB9XSxcclxuICAgIGhvc3Q6IHtcclxuICAgICAgICAnW2F0dHIuZmlsZXNpemVdJzogJ2ZpbGVzaXplID8gZmlsZXNpemUgOiBudWxsJyxcclxuICAgICAgICAnW2F0dHIubWluc2l6ZV0nOiAnbWluc2l6ZSA/IG1pbnNpemUgOiBudWxsJyxcclxuICAgICAgICAnW2F0dHIubWF4c2l6ZV0nOiAnbWF4c2l6ZSA/IG1heHNpemUgOiBudWxsJ1xyXG4gICAgfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRmlsZVNpemVWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uQ2hhbmdlcyB7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHB1YmxpYyBmaWxlc2l6ZTogc3RyaW5nfG51bWJlcjtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgcHVibGljIG1pbnNpemU6IHN0cmluZ3xudW1iZXI7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHB1YmxpYyBtYXhzaXplOiBzdHJpbmd8bnVtYmVyO1xyXG5cclxuICAgIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGZpbGVVcGxvYWRTZXJ2aWNlOiBGaWxlVXBsb2FkU2VydmljZSl7fVxyXG5cclxuICAgIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgICAgICBpZiAoJ2ZpbGVzaXplJyBpbiBjaGFuZ2VzIFxyXG4gICAgICAgICAgICB8fCAnbWF4c2l6ZScgaW4gY2hhbmdlcyBcclxuICAgICAgICAgICAgfHwgJ21pbnNpemUnIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xyXG4gICAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcclxuICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzfG51bGwge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRvcihjKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjsgXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY3JlYXRlVmFsaWRhdG9yKCk6IHZvaWQge1xyXG4gICAgICAgIGxldCBtYXhTaXplID0gbnVsbDtcclxuICAgICAgICBpZiAoIUlzTnVsbE9yRW1wdHkodGhpcy5tYXhzaXplKSkge1xyXG4gICAgICAgICAgICBtYXhTaXplID0gdGhpcy5maWxlVXBsb2FkU2VydmljZS5wYXJzZVNpemUodGhpcy5tYXhzaXplKTtcclxuICAgICAgICB9IGVsc2UgaWYoIUlzTnVsbE9yRW1wdHkodGhpcy5maWxlc2l6ZSkpIHtcclxuICAgICAgICAgICAgbWF4U2l6ZSA9IHRoaXMuZmlsZVVwbG9hZFNlcnZpY2UucGFyc2VTaXplKHRoaXMuZmlsZXNpemUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbWluU2l6ZSA9IHRoaXMuZmlsZVVwbG9hZFNlcnZpY2UucGFyc2VTaXplKHRoaXMubWluc2l6ZSk7XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBGaWxlVXBsb2FkVmFsaWRhdG9ycy5zaXplUmFuZ2UoeyBtYXhTaXplLCBtaW5TaXplIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYGZpbGVzbGltaXRgIHZhbGlkYXRvciB0byBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcclxuICogYGZpbGVzbGltaXRgIGF0dHJpYnV0ZS5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICpcclxuICogYGBgXHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIGZpbGVzbGltaXQ9XCIyXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgW2ZpbGVzbGltaXRdPVwiMlwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIGBgYFxyXG4gKlxyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ2ZpbGUtdXBsb2FkW2ZpbGVzbGltaXRdW2Zvcm1Db250cm9sTmFtZV0sIGZpbGUtdXBsb2FkW2ZpbGVzbGltaXRdW2Zvcm1Db250cm9sXSwgZmlsZS11cGxvYWRbZmlsZXNsaW1pdF1bbmdNb2RlbF0nLFxyXG4gICAgcHJvdmlkZXJzOiBbe1xyXG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXHJcbiAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRmlsZXNMaW1pdFZhbGlkYXRvciksXHJcbiAgICAgICAgbXVsdGk6IHRydWVcclxuICAgIH1dLFxyXG4gICAgaG9zdDogeydbYXR0ci5maWxlc2xpbWl0XSc6ICdmaWxlc2xpbWl0ID8gZmlsZXNsaW1pdCA6IG51bGwnfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRmlsZXNMaW1pdFZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25DaGFuZ2VzIHtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgcHVibGljIGZpbGVzbGltaXQ6IHN0cmluZ3xudW1iZXI7XHJcblxyXG4gICAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xyXG5cclxuICAgIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgICAgICBpZiAoJ2ZpbGVzbGltaXQnIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xyXG4gICAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9yc3xudWxsIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxlc2xpbWl0ICE9IG51bGwgPyB0aGlzLnZhbGlkYXRvcihjKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47IFxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NyZWF0ZVZhbGlkYXRvcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IEZpbGVVcGxvYWRWYWxpZGF0b3JzLmZpbGVzTGltaXQodHlwZW9mIHRoaXMuZmlsZXNsaW1pdCA9PT0gJ3N0cmluZycgPyBwYXJzZUludCh0aGlzLmZpbGVzbGltaXQsIDEwKSA6IHRoaXMuZmlsZXNsaW1pdCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIERpcmVjdGl2ZSB0aGF0IGFkZHMgdGhlIGBhY2NlcHRgIHZhbGlkYXRvciB0byBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcclxuICogYGFjY2VwdGAgYXR0cmlidXRlLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgYWNjZXB0PVwiZmlsZV9leHRlbnNpb258YXVkaW8vKnx2aWRlby8qfGltYWdlLyp8bWVkaWFfdHlwZVwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIFthY2NlcHRdPVwiZmlsZV9leHRlbnNpb258YXVkaW8vKnx2aWRlby8qfGltYWdlLyp8bWVkaWFfdHlwZVwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIGBgYFxyXG4gKiBcclxuICogVG8gc3BlY2lmeSBtb3JlIHRoYW4gb25lIHZhbHVlLCBzZXBhcmF0ZSB0aGUgdmFsdWVzIHdpdGggYSBjb21tYSAoZS5nLiA8ZmlsZS11cGxvYWQgYWNjZXB0PVwiYXVkaW8vKix2aWRlby8qLGltYWdlLypcIj48L2ZpbGUtdXBsb2FkPi5cclxuICpcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICdmaWxlLXVwbG9hZFthY2NlcHRdW2Zvcm1Db250cm9sTmFtZV0sIGZpbGUtdXBsb2FkW2FjY2VwdF1bZm9ybUNvbnRyb2xdLCBmaWxlLXVwbG9hZFthY2NlcHRdW25nTW9kZWxdJyxcclxuICAgIHByb3ZpZGVyczogW3tcclxuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxyXG4gICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZpbGVzQWNjZXB0VmFsaWRhdG9yKSxcclxuICAgICAgICBtdWx0aTogdHJ1ZVxyXG4gICAgfV0sXHJcbiAgICBob3N0OiB7J1thdHRyLmFjY2VwdF0nOiAnYWNjZXB0ID8gYWNjZXB0IDogbnVsbCd9XHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBGaWxlc0FjY2VwdFZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25DaGFuZ2VzIHtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgcHVibGljIGFjY2VwdDogc3RyaW5nO1xyXG5cclxuICAgIHByaXZhdGUgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcclxuXHJcbiAgICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCdhY2NlcHQnIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xyXG4gICAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcclxuICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZShjOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzfG51bGwge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjY2VwdCAhPSBudWxsID8gdGhpcy52YWxpZGF0b3IoYykgOiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NyZWF0ZVZhbGlkYXRvcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IEZpbGVVcGxvYWRWYWxpZGF0b3JzLmFjY2VwdCh0aGlzLmFjY2VwdC5zcGxpdCgnLCcpKTtcclxuICAgIH1cclxufVxyXG4iXX0=